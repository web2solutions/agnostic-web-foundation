<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"DataAPI.js.html":{"id":"DataAPI.js.html","title":"Source: DataAPI.js","body":" Agnostic Web Application Foundation Modules utils Classes DataAPIFoundationLocalDatabaseTransport Source: DataAPI.js /* global localStorage, navigator, window */ // import Dexie from 'dexie' import mongoose from 'mongoose' import { createMethodSignature, GUID, toJSON } from './utils' /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class DataAPI * @description Models Data API * @extends Data * @extends DataTransportLocal * @param {object} config - Configuration factory * @param {string} config.foundation - Provide Accesss to Foundation scope * @param {string} config.entity - Data entity which the created object is handling * @param {boolean} config.strategy - Data transport strategy * @param {boolean} config.schema - Access to related data schema * @example const dataAPI = new DataAPI({ foundation , // Foundation instance, object entity, // entity name, string strategy, // data strategy, string schema // data schema, mongoose schema }) */ export default class DataAPI { #_foundation #_entity #_strategy #_schema #_pagination #_stateChangeStorageName constructor ({ foundation, entity, strategy, schema } = {}) { this.#_entity = entity this.#_strategy = strategy // offlineFirst, onlineFirst, offline, online this.#_schema = schema this.#_foundation = foundation this.#_pagination = { offset: 0, limit: 30 } this.#_stateChangeStorageName = `__$tabEntityStateChange_${this.#_entity}` this.#_foundation.localDatabaseTransport.addSchema(this.#_entity, this.#_schema) this.#_listenToAllOtherTabsStateChanges() } /** * @memberof DataAPI.entity * @member {getter} DataAPI.entity * @example console.log(DataAPI.entity) * @description Gets the entity name which which DataAPI instance is handling out * @return {object} this.#_entity */ get entity () { return this.#_entity } /** * @memberof DataAPI.schema * @member {getter} DataAPI.schema * @example console.log(DataAPI.schema) * @description Gets the data schema related to this Entity Data API * @return {object} this.#_schema */ get schema () { return this.#_schema } /** * @memberof DataAPI * @member {getter} DataAPI.strategy * @example console.log(DataAPI.strategy) * @description Gets the data strategy currently being used * @return {string} this.#_strategy */ get strategy () { return this.#_strategy } /** * @Method DataAPI.Model * @description create a Data Model based on given document * @param {object} doc - A valid document validated against mongoose schema * @param {object} schema - Mongoose based schema * @return {object} model - Mongoose document */ Model(doc, schema) { const modelSystem = mongoose.Document modelSystem.prototype.isValid = () =&gt; modelSystem.prototype.validateSync return modelSystem(doc, schema) } /** * @async * @Method DataAPI.add * @description add a new document to the storage * @param {object} doc - A valid document validated against mongoose schema * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Created document */ async add (doc = {}) { let data = null let error = null let rawObj = {} try { const model = new this.Model(doc, this.#_schema) const invalid = model.validateSync() if (invalid) { return createMethodSignature(invalid, data) } rawObj = toJSON(model) const __id = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .add({ ...rawObj }) data = { __id, ...rawObj } } catch (e) { error = e } this.#_foundation.triggerEvent(`collection:add:${this.#_entity.toLowerCase()}`, { foundation: this.#_foundation, entity: this.#_entity, document: rawObj, data, error, }) const state = { action: 'add', data, error, document: rawObj } this.#_sendStateChangeToAllOtherTabs(state) return createMethodSignature(error, data) } /** * @async * @Method DataAPI.edit * @description Edit a document on the storage * @param {string|number} primaryKey - The primary key value of the desired document * @param {object} doc - A valid document validated against mongoose schema * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Edited document */ async edit (primaryKey, doc) { let data = null let error = null let rawObj = {} try { const model = new this.Model(doc, this.#_schema) const invalid = model.validateSync() if (invalid) { return createMethodSignature(invalid, data) } rawObj = toJSON(model) rawObj.__id = primaryKey console.debug('query', {primaryKey, rawObj}) const response = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .put({ ...rawObj }) // .update({ __id: primaryKey }, { ...rawObj }) console.debug('response', response) data = { __id: primaryKey, ...rawObj } /* if (response.modifiedCount === 1) { data = { __id: primaryKey, ...rawObj } } else { data = null error = { message: 'Critical query error on update', response } } */ } catch (e) { console.log(e) error = e } this.#_foundation.triggerEvent( `collection:edit:${this.#_entity.toLowerCase()}`, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, document: rawObj, data, error } ) const state = { action: 'edit', data, error, document: rawObj, primaryKey } this.#_sendStateChangeToAllOtherTabs(state) return createMethodSignature(error, data) } /** * @async * @Method DataAPI.delete * @description delete a document from the storage * @param {string|number} primaryKey - The primary key value of the desired document * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Deleted document */ async delete (primaryKey) { let data = null let error = null let rawObj = {} try { const __id = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .delete(primaryKey) // console.error({ __id }) data = { __id: primaryKey } } catch (e) { error = e } this.#_foundation.triggerEvent( `collection:delete:${this.#_entity.toLowerCase()}`, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, data, error } ) const state = { action: 'delete', data, error, primaryKey } this.#_sendStateChangeToAllOtherTabs(state) return createMethodSignature(error, data) } /** * @async * @Method DataAPI.findById * @description find a document from the storage by ID * @param {string|number} primaryKey - The primary key value of the desired document * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Found document */ async findById (primaryKey) { let data = null let error = null try { primaryKey = parseInt(primaryKey) const doc = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .get(primaryKey) // console.debug({ __id: primaryKey, doc }) if (doc) { if (doc.__id === primaryKey) { data = { __id: primaryKey, ...doc } } } } catch (e) { console.error('error', error) error = e } return createMethodSignature(error, data) } /** * @async * @Method DataAPI.findAll * @description find all documents * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {array} signature.data - Array of Found documents */ async findAll(query = {}) { let data = null let error = null try { const documents = await this.#_foundation .localDatabaseTransport .collection(this.#_entity) .find(query) .toArray() data = documents } catch (e) { error = e } return createMethodSignature(error, data) } /** * @async * @Method DataAPI.find * @description find all documents based on the given query * @param {object|null} query - The query object to search documents * @param {object} pagination - Pagination object. If not provided will assume internaly set pagination. * @param {number} pagination.offset - Offset. Default 0. * @param {number} pagination.limit - Limit. Default 30. * @example User.find({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {array} signature.data - Array of Found documents */ async find(query = {}, pagination = this.#_pagination) { let { offset, limit } = pagination let data = null let error = null try { const documents = await this.#_foundation .localDatabaseTransport .collection(this.#_entity) .find(query) .reverse() .offset(offset) .limit(limit) .toArray() data = documents } catch (e) { error = e } return createMethodSignature(error, data) } /** * @async * @Method DataAPI.count * @description count all documents based on the given query * @param {object} query - The query object to count documents * @example User.count({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {number} signature.data - Documents counter */ async count (query = {}) { let data = null let error = null try { const counter = await this.#_foundation .localDatabaseTransport .collection(this.#_entity) .count(query) data = counter } catch (e) { error = e } return createMethodSignature(error, data) } #_listenToAllOtherTabsStateChanges() { window.addEventListener('storage', (event) =&gt; { if (event.key === this.#_stateChangeStorageName) { const { key, newValue, oldValue } = event if (newValue) { // console.log('DATAAPI -&gt; got new state change', { key, newValue, oldValue }) const jsonState = JSON.parse(newValue) const { error, data, entity, action, source, document } = jsonState // console.error({ error, data, entity, action, source, document }) const eventObj = { foundation: this.#_foundation, entity: entity, document: document, data, error } const eventName = `collection:${action}:${entity.toLowerCase()}` // console.log(eventName, eventObj) this.#_foundation.triggerEvent(eventName, eventObj) } // oldValue } }) } #_sendStateChangeToAllOtherTabs(state = { action: '', data: null, error: null, document: {} }) { state.source = this.#_foundation.tabId state.entity = this.#_entity const stateChange = JSON.stringify(state) window.localStorage.setItem(this.#_stateChangeStorageName, stateChange) window.localStorage.removeItem(this.#_stateChangeStorageName) } } × Search results Close Sponsored by WEB2 Solutions "},"Foundation.js.html":{"id":"Foundation.js.html","title":"Source: Foundation.js","body":" Agnostic Web Application Foundation Modules utils Classes DataAPIFoundationLocalDatabaseTransport Source: Foundation.js /* global localStorage, navigator, window */ import { createMethodSignature, GUID, Schema } from './utils' import DataAPI from './DataAPI' import LocalDatabaseTransport from './LocalDatabaseTransport' import EventSystem from './EventSystem' const _workerOnMessage = function (event) { // console.error('_workerOnMessage') const { cmd /* , message */ } = event.data switch (cmd) { case 'responseClientId': this.triggerEvent('worker:responseClientId', { foundation: this, worker: this.applicationWorker, ...event.data }) break default: console.log(`Sorry, we are out of ${cmd}.`) } } /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class Foundation * @description Foundation boostrap class * @extends EventSystem * @param {object} config - Foundation configuration * @param {string} config.name - Foundation name * @param {string} config.dataStrategy - Data strategy. Recognized values: offlineFirst, onlineFirst, offline, online * @param {boolean} config.useWorker - Use a ServiceWorker in Background * @param {object} config.schemas - map of data schemas * @example {@lang javascript} import Foundation from './Foundation' import mongoose from 'mongoose' const ProductSchema = new mongoose.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new mongoose.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Foundation({ name: 'My App', useWorker: true, dataStrategy: 'offlineFirst', schemas: { User: UserSchema, Product: ProductSchema } }) foundation.on('foundation:start', function (eventObj){ const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start foundation and get it ready to be used await foundation.start() */ export default class Foundation extends EventSystem { #_schemas #_name #_dataStrategy #_started #_models #_guid #_useWorker #_workers #_tabId constructor ({ name = 'My Foundation Name', dataStrategy = 'offlineFirst', useWorker = false, schemas = {} } = {}) { super() this.#_name = name this.#_dataStrategy = dataStrategy this.#_useWorker = useWorker this.#_schemas = schemas this.#_started = false this.#_guid = GUID() this.#_models = {} this.#_useWorker = useWorker || false this.#_workers = {} this.localDatabaseTransport = new LocalDatabaseTransport() this.#_tabId = GUID() // assume new Id on every refresh } /** * @member {getter} Foundation.dataStrategy * @Description Get the data strategy being used.&lt;br&gt; Possible values are: offlineFirst, onlineFirst, offline, online. &lt;br&gt; Default: offlineFirst * @example console.log(Foundation.dataStrategy) * @return {string} this.#_dataStrategy */ get dataStrategy () { return this.#_dataStrategy } /** * @member {getter} Foundation.guid * @description Get the Foundation Session guid currently being used. * @example console.log(Foundation.guid) */ get guid () { return this.#_guid } /** * @member {getter} Foundation.data * @description Get the Foundation data API(DataAPI) * @example const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug(Eduardo) // { // data: {__id: 1, _id: \"600e0ae8d9d7f50000e1444b\", name: \"Eduardo Almeida\", username: \"web2\", id: \"600e0ae8d9d7f50000e1444b\"} // error: null // } */ get data() { return this.#_models } /** * @member {getter} Foundation.tabId * @description Get the Browser tab ID * @example console.log(foundation.tabId) */ get tabId() { return this.#_tabId } /** * @member {getter} Foundation.name * @name Foundation.name * @description Get the Foundation name * @example console.log(Foundation.name) */ get name () { return this.#_name } /** * @member {setter} Foundation.name * @name Foundation.name * @description Set the Foundation name * @example Foundation.name = 'Provide the name here' * @param {string} name - Foundation name */ set name (name) { this.#_name = name } /** * @member {getter} Foundation.started * @description Get the start state * @example console.log(Foundation.started) */ get started () { return this.#_started } /** * @memberof Foundation * @member {getter} Foundation.applicationWorker * @example Foundation.applicationWorker.postMessage() * @description Get the Foundation worker */ get applicationWorker() { return this.#_workers.foundation } #setModel(entity = '', dataAPI = {}) { let _error = null let _data = null try { this.#_models[entity] = dataAPI _data = this.#_models[entity] } catch (error) { console.error('EROROR', error) _error = error } return createMethodSignature(_error, _data) } /** * @memberof Foundation * @member {getter} Foundation.Schema * @example new Foundation.Schema({}) * @description Creates new data schema * @returns schema creator */ static get Schema() { return Schema } #mapModels(schemas) { let _error = null let _data = null try { for (const entity in schemas) { if (Object.prototype.hasOwnProperty.call(schemas, entity)) { // console.debug('for (const entity in schemas)', entity) const strategy = 'offlineFirst' const schema = schemas[entity] const dataAPI = new DataAPI({ foundation: this, entity, strategy, schema }) this.#setModel(entity, dataAPI) } } _data = this.#_models } catch (error) { console.error(error) _error = error } return createMethodSignature(_error, _data) } /** * @member {getter} Foundation.useWorker * @Description flag if is there ServiceWorker being used * @return {boolean} */ get useWorker () { return this.#_useWorker } /** * @Method Foundation.setGuidStorage * @description save Foundation GUID to localStorage * @param {string} guid * @return Foundation GUID saved on localStorage */ setGuidStorage (guid) { localStorage.setItem('guid', guid) return localStorage.getItem('guid') } /** * @Method Foundation.getGuidStorage * @description get Foundation GUID saved on localStorage * @example foundation.getGuidStorage() * @return Foundation GUID saved on localStorage */ getGuidStorage () { return localStorage.getItem('guid') || false } /** * @Method Foundation.setupAppGuid * @description check if Foundation has a GUID saved o * @return Foundation GUID saved on localStorage */ setupAppGuid () { const guidCache = this.getGuidStorage() || false if (guidCache) { this.#_guid = guidCache } else { this.setGuidStorage(this.#_guid) } return this.getGuidStorage() } /** * @async * @Method Foundation.#registerApplicationWorker * @description Setup and Register the main Service worker used by foundation core * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Worker Registration Object */ #registerApplicationWorker (workerFile = 'ServiceWorker.js') { const self = this return new Promise((resolve, reject) =&gt; { if ('serviceWorker' in navigator) { navigator.serviceWorker .register('/' + workerFile, { // scope: '/' }) .then(function (reg) { // registration worked navigator.serviceWorker.addEventListener('message', _workerOnMessage.bind(self)) if (reg.installing) { self.#_workers['foundation'] = reg.installing self.#_workers['foundation'].postMessage({ cmd: 'getClientId', message: null }) } else if (reg.active) { self.#_workers['foundation'] = reg.active self.#_workers['foundation'].postMessage({ cmd: 'getClientId', message: null }) } resolve(createMethodSignature(null, reg)) }) .catch(function (error) { // registration failed resolve(createMethodSignature(error, null)) }) } }) } /** * @async * @Method Foundation.#registerWorker * @description Setup and Register a Service worker and get it ready for usage into your application scope * @param {string} name - Worker name. Used to access it from the namespace * @param {string} workerFile - Worker file name * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Worker Registration Object */ #registerWorker (name = '', workerFile = 'ServiceWorker.js') { const self = this return new Promise((resolve, reject) =&gt; { if ('serviceWorker' in navigator) { navigator.serviceWorker .register('/' + workerFile, { // scope: '/' }) .then(function (reg) { // registration worked navigator.serviceWorker.addEventListener('message', _workerOnMessage.bind(self)) if (reg.installing) { self.#_workers[name] = reg.installing self.#_workers[name].postMessage({ cmd: 'getClientId', message: null }) } else if (reg.active) { self.#_workers[name] = reg.active self.#_workers[name].postMessage({ cmd: 'getClientId', message: null }) } resolve(createMethodSignature(null, reg)) }) .catch(function (error) { // registration failed resolve(createMethodSignature(error, null)) }) } }) } /** * @Private * @description Starts foundation stack required items * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Foundation data */ async #startVitals () { let _error = null let _data = null try { this.setupAppGuid() const mapModels = this.#mapModels(this.#_schemas) await this.localDatabaseTransport.connect() // start database // start all here _data = { status: { mapModels } } } catch (error) { console.error(error) _error = error } this.triggerEvent('foundation:startVitals', { foundation: this, error: _error, data: _data }) return createMethodSignature(_error, _data) } /** * @async * @Method Foundation.start * @description Starts foundation stack and get it ready to use. &lt;br&gt; it calls this.#startVitals() internally * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Foundation data */ async start () { let _error = null let _data = null try { const vitals = await this.#startVitals() if (this.useWorker) { await this.#registerApplicationWorker() } this.#_started = true _data = { ...vitals.data, started: this.#_started } } catch (error) { console.error(error) _error = error } this.triggerEvent('foundation:start', { foundation: this, error: _error, data: _data }) // console.warn('STARTED&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;', this) return createMethodSignature(_error, _data) } } × Search results Close Sponsored by WEB2 Solutions "},"LocalDatabaseTransport.js.html":{"id":"LocalDatabaseTransport.js.html","title":"Source: LocalDatabaseTransport.js","body":" Agnostic Web Application Foundation Modules utils Classes DataAPIFoundationLocalDatabaseTransport Source: LocalDatabaseTransport.js import dexie from 'dexie' import 'dexie-mongoify' import { createMethodSignature, mongooseToDexieTableString } from './utils' dexie.debug = false /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class LocalDatabaseTransport * @description Database transport for IndexedDB * @extends dexie * @see The Data Transport is set into the {@link Foundation} stack and it is consumed inside {@link DataAPI} to persist data locally. * @see {@link LocalDatabaseTransport} extends {@link https://dexie.org/docs/Dexie/Dexie|Dexie} as database handler for IndexedDB. See {@link https://dexie.org/docs/Dexie/Dexie|Dexie} * @param {object} config - Transport configuration * @param {number} config.version - Database version. &lt;br&gt;Same as IndexedDB database version. * @param {object} config.tables - Database tables. &lt;br&gt;Dexie tables configuration. * @param {string} config.dbName - Database name. &lt;br&gt;Same as IndexedDB database name. * @example {@lang javascript} import LocalDatabaseTransport from './LocalDatabaseTransport' import { Schema } from './utils' const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const ProductSchema = new Schema({ // ... }) const dbName = 'MyDatabaseName' const localDataTransport = new LocalDatabaseTransport({ version: 1, // default 1 tables: {}, // default {} dbName }) // or const localDataTransport = new LocalDatabaseTransport({ dbName }) localDataTransport.addSchema('User', UserSchema) localDataTransport.addSchema('Product', ProductSchema) await localDataTransport.connect() const Biden = await localDataTransport.table('User').add({ name: 'Joe Biden', username: 'biden'}) const Ferrari = await localDataTransport.table('Product').add({ name: 'Ferrari', vendor: 'Ferrari', price_cost: 3000000}) */ export default class LocalDatabaseTransport extends dexie { #_version #_tables #_connected #_schemas #_dbName constructor ({ version = 1, tables = {}, dbName = 'DatabaseName' } = {}) { // console.error('STARTED LocalDatabaseTransport') // run the super constructor Dexie(databaseName) to create the IndexedDB // database. super(dbName) this.#_dbName = dbName this.#_version = version this.#_tables = tables this.#_connected = false this.#_schemas = {} } #_setTables() { for (const entity in this.#_schemas) { if (Object.prototype.hasOwnProperty.call(this.#_schemas, entity)) { // console.error(entity) this.#_tables[entity] = mongooseToDexieTableString( this.#_schemas[entity] ) } } } /** * @Method LocalDatabaseTransport.addSchema * @description A a Data Schema into the Schema tree * @param {string} schemaName - The schema name. Same as Entity name. * @param {object} schema - A valid mongoose like schema * @example const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) localDataTransport.addSchema('User', UserSchema) * @return {object} schema - The schema enty from inside the Schema tree */ addSchema (schemaName, schema) { this.#_schemas[schemaName] = schema return this.#_schemas[schemaName] } /** * @async * @Method LocalDatabaseTransport.connect * @description Setup connection to local database * @return Foundation GUID saved on localStorage * @example await localDataTransport.connect() * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error information * @return {object} signature.data - Connection information */ async connect() { let error = null let data = null try { this.#_setTables() this .version(this.#_version) .stores(this.#_tables) // for (const tableName in this.#_tables) { // this[tableName] = this.table(tableName) // } const open = await this.open() data = open } catch (e) { error = e data = null } return createMethodSignature(error, data) } } × Search results Close Sponsored by WEB2 Solutions "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" Agnostic Web Application Foundation Modules utils Classes DataAPIFoundationLocalDatabaseTransport Source: utils.js import lunr from 'lunr' import mongoose from 'mongoose' /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @module utils * */ /** * createMethodSignature * Create default signature method object * @function * @param {string|object} error - The string or error object if have any * @param {object|array|number|string|boolean} data - Information about method execution * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object|array|number|string|boolean} signature.data - Execution data */ export const createMethodSignature = (error = null, data = null) =&gt; { return { error, data } } /** * GUID * generates a Universally unique identifier string - alias to uuid() * @function * @return {string} guid / uuid */ export const GUID = () =&gt; { return uuid() } /** * uuid * generates a Universally unique identifier string * @function * @return {string} guid / uuid */ export function uuid () { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { const r = (Math.random() * 16) | 0 const v = c === 'x' ? r : (r &amp; 0x3) | 0x8 return v.toString(16) }) } /** * toJSON - stringify and parse an object&lt;br&gt; It uses native JSON internally. * @function * @param {string|object} obj - Valid JSON object or string * @return {object} new JSON object */ export function toJSON (obj) { if (typeof obj === 'string') { return JSON.parse(obj) } return JSON.parse(JSON.stringify(obj)) } /** * mongooseToDexieTableString * convert given Mongoose schema to a Dexie Table columns configuration. &lt;br&gt; * All columns inside returned configuration are indexed at IndexedDB * prepend __id as local primary key and _id for remote primary key * @function * @return {string} Dexie table configuration string */ export function mongooseToDexieTableString (schema) { const cols = [] for (const propertyName in schema.paths) { if (Object.prototype.hasOwnProperty.call(schema.paths, propertyName)) { const property = schema.paths[propertyName] const { // instance, _index // , // isRequired } = property // console.debug(propertyName, property) if (propertyName === '_id' || propertyName === '__id') { continue } if (!_index) { continue } cols.push(propertyName) } } return `++__id,_id${cols.length &gt; 0 ? (',' + cols.join(',')) : ''}` } /** * getSearchTokenStream * generates a lunr search token. See {@link https://lunrjs.com/guides/searching.html|lunr search} * @function * @return {array} token */ export function getSearchTokenStream (text = '') { const index = lunr() return index.pipeline.run(lunr.tokenizer(text)) } export const Schema = mongoose.Schema × Search results Close Sponsored by WEB2 Solutions "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Agnostic Web Application Foundation Modules utils Classes DataAPIFoundationLocalDatabaseTransport Modules Classes DataAPI Models Data API. Foundation Foundation boostrap class. LocalDatabaseTransport Database transport for IndexedDB. × Search results Close Sponsored by WEB2 Solutions "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Agnostic Web Application Foundation Modules utils Classes DataAPIFoundationLocalDatabaseTransport Classes Classes DataAPI Models Data API. Foundation Foundation boostrap class. LocalDatabaseTransport Database transport for IndexedDB. × Search results Close Sponsored by WEB2 Solutions "},"index.html":{"id":"index.html","title":"Index","body":" Agnostic Web Application Foundation Modules utils Classes DataAPIFoundationLocalDatabaseTransport Documentation DRAFT Links Code documentation Unit tests Report × Search results Close Sponsored by WEB2 Solutions "},"DataAPI.html":{"id":"DataAPI.html","title":"Class: DataAPI","body":" Agnostic Web Application Foundation Modules utils Classes DataAPIFoundationLocalDatabaseTransport Class: DataAPI DataAPI new DataAPI(config) Models Data API. Models Data API Parameters: Name Type Description config object Configuration factory Properties Name Type Description foundation string Provide Accesss to Foundation scope entity string Data entity which the created object is handling strategy boolean Data transport strategy schema boolean Access to related data schema Author: Eduardo Perotta de Almeida Source: DataAPI.js, line 7 Example const dataAPI = new DataAPI({ foundation , // Foundation instance, object entity, // entity name, string strategy, // data strategy, string schema // data schema, mongoose schema }) Extends Data DataTransportLocal Members &lt;static&gt; strategy :getter Gets the data strategy currently being used. Gets the data strategy currently being used Type: getter Source: DataAPI.js, line 75 Example console.log(DataAPI.strategy) Methods &lt;async, static&gt; add(doc) add a new document to the storage. add a new document to the storage Parameters: Name Type Description doc object A valid document validated against mongoose schema Source: DataAPI.js, line 98 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Created document Type object &lt;async, static&gt; count(query) count all documents based on the given query. count all documents based on the given query Parameters: Name Type Description query object The query object to count documents Source: DataAPI.js, line 328 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Documents counter Type number Example User.count({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) &lt;async, static&gt; delete(primaryKey) delete a document from the storage. delete a document from the storage Parameters: Name Type Description primaryKey string | number The primary key value of the desired document Source: DataAPI.js, line 199 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Deleted document Type object &lt;async, static&gt; edit(primaryKey, doc) Edit a document on the storage. Edit a document on the storage Parameters: Name Type Description primaryKey string | number The primary key value of the desired document doc object A valid document validated against mongoose schema Source: DataAPI.js, line 139 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Edited document Type object &lt;async, static&gt; find(query, pagination) find all documents based on the given query. find all documents based on the given query Parameters: Name Type Description query object | null The query object to search documents pagination object Pagination object. If not provided will assume internaly set pagination. Properties Name Type Description offset number Offset. Default 0. limit number Limit. Default 30. Source: DataAPI.js, line 292 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Array of Found documents Type array Example User.find({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) &lt;async, static&gt; findAll() find all documents. find all documents Source: DataAPI.js, line 268 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Array of Found documents Type array &lt;async, static&gt; findById(primaryKey) find a document from the storage by ID. find a document from the storage by ID Parameters: Name Type Description primaryKey string | number The primary key value of the desired document Source: DataAPI.js, line 237 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Found document Type object &lt;static&gt; Model(doc, schema) create a Data Model based on given document. create a Data Model based on given document Parameters: Name Type Description doc object A valid document validated against mongoose schema schema object Mongoose based schema Source: DataAPI.js, line 86 Returns: model - Mongoose document Type object × Search results Close Sponsored by WEB2 Solutions "},"Foundation.html":{"id":"Foundation.html","title":"Class: Foundation","body":" Agnostic Web Application Foundation Modules utils Classes DataAPIFoundationLocalDatabaseTransport Class: Foundation Foundation new Foundation(config) Foundation boostrap class. Foundation boostrap class Parameters: Name Type Description config object Foundation configuration Properties Name Type Description name string Foundation name dataStrategy string Data strategy. Recognized values: offlineFirst, onlineFirst, offline, online useWorker boolean Use a ServiceWorker in Background schemas object map of data schemas Author: Eduardo Perotta de Almeida Source: Foundation.js, line 31 Example import Foundation from './Foundation' import mongoose from 'mongoose' const ProductSchema = new mongoose.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new mongoose.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Foundation({ name: 'My App', useWorker: true, dataStrategy: 'offlineFirst', schemas: { User: UserSchema, Product: ProductSchema } }) foundation.on('foundation:start', function (eventObj){ const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start foundation and get it ready to be used await foundation.start() Extends EventSystem Members &lt;static&gt; applicationWorker :getter Get the Foundation worker. Get the Foundation worker Type: getter Source: Foundation.js, line 218 Example Foundation.applicationWorker.postMessage() &lt;static&gt; data :getter Get the Foundation data API(DataAPI). Get the Foundation data API(DataAPI) Type: getter Source: Foundation.js, line 159 Example const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug(Eduardo) // { // data: {__id: 1, _id: \"600e0ae8d9d7f50000e1444b\", name: \"Eduardo Almeida\", username: \"web2\", id: \"600e0ae8d9d7f50000e1444b\"} // error: null // } &lt;static&gt; dataStrategy :getter Get the data strategy being used. Get the data strategy being used. Possible values are: offlineFirst, onlineFirst, offline, online. Default: offlineFirst Type: getter Source: Foundation.js, line 140 Example console.log(Foundation.dataStrategy) &lt;static&gt; guid :getter Get the Foundation Session guid currently being used. Get the Foundation Session guid currently being used. Type: getter Source: Foundation.js, line 150 Example console.log(Foundation.guid) &lt;static&gt; name :getter Get the Foundation name. Get the Foundation name Type: getter Source: Foundation.js, line 188 Example console.log(Foundation.name) &lt;static&gt; name :setter Set the Foundation name. Set the Foundation name Type: setter Source: Foundation.js, line 198 Example Foundation.name = 'Provide the name here' &lt;static&gt; Schema :getter Creates new data schema. Creates new data schema Type: getter Source: Foundation.js, line 241 Example new Foundation.Schema({}) &lt;static&gt; started :getter Get the start state. Get the start state Type: getter Source: Foundation.js, line 209 Example console.log(Foundation.started) &lt;static&gt; tabId :getter Get the Browser tab ID. Get the Browser tab ID Type: getter Source: Foundation.js, line 178 Example console.log(foundation.tabId) &lt;static&gt; useWorker :getter flag if is there ServiceWorker being used. flag if is there ServiceWorker being used Type: getter Source: Foundation.js, line 278 Methods &lt;async, static&gt; registerApplicationWorker() Setup and Register the main Service worker used by foundation core. Setup and Register the main Service worker used by foundation core Source: Foundation.js, line 323 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Worker Registration Object Type object &lt;async, static&gt; registerWorker(name, workerFile) Setup and Register a Service worker and get it ready for usage into your application scope. Setup and Register a Service worker and get it ready for usage into your application scope Parameters: Name Type Description name string Worker name. Used to access it from the namespace workerFile string Worker file name Source: Foundation.js, line 359 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Worker Registration Object Type object &lt;static&gt; getGuidStorage() get Foundation GUID saved on localStorage. get Foundation GUID saved on localStorage Source: Foundation.js, line 298 Returns: Foundation GUID saved on localStorage Example foundation.getGuidStorage() &lt;static&gt; setGuidStorage(guid) save Foundation GUID to localStorage. save Foundation GUID to localStorage Parameters: Name Type Description guid string Source: Foundation.js, line 287 Returns: Foundation GUID saved on localStorage &lt;static&gt; setupAppGuid() check if Foundation has a GUID saved o. check if Foundation has a GUID saved o Source: Foundation.js, line 308 Returns: Foundation GUID saved on localStorage &lt;async, static&gt; start() Starts foundation stack and get it ready to use. Starts foundation stack and get it ready to use. it calls this.#startVitals() internally Source: Foundation.js, line 432 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Foundation data Type object × Search results Close Sponsored by WEB2 Solutions "},"LocalDatabaseTransport.html":{"id":"LocalDatabaseTransport.html","title":"Class: LocalDatabaseTransport","body":" Agnostic Web Application Foundation Modules utils Classes DataAPIFoundationLocalDatabaseTransport Class: LocalDatabaseTransport LocalDatabaseTransport new LocalDatabaseTransport(config) Database transport for IndexedDB. Database transport for IndexedDB Parameters: Name Type Description config object Transport configuration Properties Name Type Description version number Database version. Same as IndexedDB database version. tables object Database tables. Dexie tables configuration. dbName string Database name. Same as IndexedDB database name. Author: Eduardo Perotta de Almeida Source: LocalDatabaseTransport.js, line 8 See: The Data Transport is set into the Foundation stack and it is consumed inside DataAPI to persist data locally. LocalDatabaseTransport extends Dexie as database handler for IndexedDB. See Dexie Example import LocalDatabaseTransport from './LocalDatabaseTransport' import { Schema } from './utils' const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const ProductSchema = new Schema({ // ... }) const dbName = 'MyDatabaseName' const localDataTransport = new LocalDatabaseTransport({ version: 1, // default 1 tables: {}, // default {} dbName }) // or const localDataTransport = new LocalDatabaseTransport({ dbName }) localDataTransport.addSchema('User', UserSchema) localDataTransport.addSchema('Product', ProductSchema) await localDataTransport.connect() const Biden = await localDataTransport.table('User').add({ name: 'Joe Biden', username: 'biden'}) const Ferrari = await localDataTransport.table('Product').add({ name: 'Ferrari', vendor: 'Ferrari', price_cost: 3000000}) Extends dexie Methods &lt;static&gt; addSchema(schemaName, schema) A a Data Schema into the Schema tree. A a Data Schema into the Schema tree Parameters: Name Type Description schemaName string The schema name. Same as Entity name. schema object A valid mongoose like schema Source: LocalDatabaseTransport.js, line 90 Returns: schema - The schema enty from inside the Schema tree Type object Example const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) localDataTransport.addSchema('User', UserSchema) &lt;async, static&gt; connect() Setup connection to local database. Setup connection to local database Source: LocalDatabaseTransport.js, line 114 Returns: Foundation GUID saved on localStorage signature - Default methods signature format { error, data } Type object signature.error - Execution error information Type string | object signature.data - Connection information Type object Example await localDataTransport.connect() × Search results Close Sponsored by WEB2 Solutions "},"module-utils.html":{"id":"module-utils.html","title":"Module: utils","body":" Agnostic Web Application Foundation Modules utils Classes DataAPIFoundationLocalDatabaseTransport Module: utils Author: Eduardo Perotta de Almeida Source: utils.js, line 3 Methods &lt;static&gt; createMethodSignature(error, data) createMethodSignature Create default signature method object. createMethodSignature Create default signature method object Parameters: Name Type Description error string | object The string or error object if have any data object | array | number | string | boolean Information about method execution Source: utils.js, line 18 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Execution data Type object | array | number | string | boolean &lt;static&gt; getSearchTokenStream() getSearchTokenStream generates a lunr search token. getSearchTokenStream generates a lunr search token. See lunr search Source: utils.js, line 96 Returns: token Type array &lt;static&gt; GUID() GUID generates a Universally unique identifier string - alias to uuid(). GUID generates a Universally unique identifier string - alias to uuid() Source: utils.js, line 28 Returns: guid / uuid Type string &lt;static&gt; mongooseToDexieTableString() mongooseToDexieTableString convert given Mongoose schema to a Dexie Table columns configuration. mongooseToDexieTableString convert given Mongoose schema to a Dexie Table columns configuration. All columns inside returned configuration are indexed at IndexedDB prepend __id as local primary key and _id for remote primary key Source: utils.js, line 67 Returns: Dexie table configuration string Type string &lt;static&gt; toJSON(obj) toJSON - stringify and parse an object It uses native JSON internally. toJSON - stringify and parse an object It uses native JSON internally. Parameters: Name Type Description obj string | object Valid JSON object or string Source: utils.js, line 52 Returns: new JSON object Type object &lt;static&gt; uuid() uuid generates a Universally unique identifier string. uuid generates a Universally unique identifier string Source: utils.js, line 38 Returns: guid / uuid Type string × Search results Close Sponsored by WEB2 Solutions "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
