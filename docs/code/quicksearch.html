<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"DataEntity.js.html":{"id":"DataEntity.js.html","title":"Source: DataEntity.js","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Source: DataEntity.js /* global localStorage, navigator, window */ import EventSystem from './EventSystem' // import Dexie from 'dexie' import mongoose from 'mongoose' import { createMethodSignature, uuid, toJSON } from './utils' /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class DataEntity * @summary Data Entity API * @description When composing web applications using this library, we strongly believe the data design and plan should be the entry point of your software design. * &lt;br&gt;&lt;br&gt;The Entity Relationship diagram shall to be one of the initial documents you should to design before starting to write your software. * &lt;br&gt;&lt;br&gt;We assume the {@link https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model|Entity Relationship} and {@link https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model|Data Entity} models as technique and paradigm to design the application data. * &lt;br&gt;&lt;br&gt;If you have no idea of how agile you could to design your ER diagram, please take a look at some tools like {@Link https://www.datensen.com/data-modeling/moon-modeler-for-databases.html|Moon Modeler} * &lt;br&gt;&lt;br&gt; Every Data Entity in the system has it own encapsulated properties and methods that cares about where entity data is writen to and read from. * &lt;br&gt;&lt;br&gt; The DataEntity relies on the application instance (passed to it constructor) to access the available data transports. * &lt;br&gt;It means you can not use DataEntity prior starting a data transport layer. * &lt;br&gt;&lt;br&gt; This class is not for direct usage in your project, unless you are a core developer or want to understand what happens behind the scenes, you should consider to take a look at the {@link Foundation} class. * @extends EventSystem * @param {object} DataEntityConfig - Data Entity configuration * @param {string} DataEntityConfig.foundation - Provide Accesss to Foundation scope * @param {string} DataEntityConfig.entity - Data entity name which this dataEntity instance is handling * @param {boolean} DataEntityConfig.strategy - Data transport strategy * @param {boolean} DataEntityConfig.schema - Data schema for this Data Entity abstraction. &lt;br&gt; Do not declare the params __id and _id inside your schemas. * @example import { Schema } from '../foundation/Foundation' const schema = new Schema({ // do not declare __id // do not declare _id name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const Customer = new DataEntity({ foundation, // Foundation instance, object entity: 'Customer', // entity name, string strategy: 'offline', // data strategy, string schema // data schema, a mongoose like schema }) // listen to add Customer Data event on Data API const onAddDocEventListener = Customer.on( 'add', function(eventObj){ const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // listen to edit Customer Data event on Data API const onEditDocEventListener = Customer.on( 'edit', function (eventObj) { const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // listen to delete Customer Data event on Data API const onDeleteDocEventListener = Customer.on( 'delete', function (eventObj) { const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // Stop to listen to events to avoid memory leak or others kind of problems // like to change the state of an unmounted component. // Do something like this -&gt; before component unmount OR before window unload Customer.stopListenTo(onAddDocEventListener) Customer.stopListenTo(onEditDocEventListener) Customer.stopListenTo(onDeleteDocEventListener) */ export default class DataEntity extends EventSystem { #_foundation #_entity #_strategy #_schema #_pagination #_stateChangeStorageName constructor({ foundation = {}, entity = null, strategy = 'offline', schema = {} } = {}) { super() this.#_entity = entity /** * @memberof DataEntity * @member {property} DataEntity.#_strategy * @summary PRIVATE - Holds the data transport strategy for this Data Entity. * @description * Default strategy is &lt;b&gt;offline&lt;/b&gt;. &lt;br&gt;&lt;br&gt; * Possible values are: &lt;br&gt; * - offlineFirst&lt;br&gt; * Data will be saved on local database first.&lt;br&gt; * - onlineFirst&lt;br&gt; * Data will be saved on remote database first.&lt;br&gt; * - offline&lt;br&gt; * Data will be saved on local database only.&lt;br&gt; * - online&lt;br&gt; * Data will be saved on remote database only.&lt;br&gt; */ this.#_strategy = strategy // offlineFirst, onlineFirst, offline, online /** * @memberof DataEntity * @member {property} DataEntity.#_schema * @summary PRIVATE - Holds the data schema for this Data Entity * @description Data schema is a mongoose.Schema implementation */ this.#_schema = schema this.#_foundation = foundation /** * @memberof DataEntity * @member {property} DataEntity.#_pagination * @summary PRIVATE - default internal paging configuration * @description The default paging configuration is: offset: 0, limit 30. It means it will returns 30 documents starting on index 0. */ this.#_pagination = { offset: 0, limit: 30 } this.#_stateChangeStorageName = `__$tabEntityStateChange_${this.#_entity}` this.#_foundation.localDatabaseTransport.addSchema(this.#_entity, this.#_schema) this.#_listenToAllOtherSessionsStateChanges() } /** * @memberof DataEntity * @member {getter} DataEntity.entity * @example console.log(DataEntity.entity) * @description Gets the entity name which which DataEntity instance is handling out * @return {object} this.#_entity */ get entity () { return this.#_entity } /** * @memberof DataEntity * @member {getter} DataEntity.schema * @example console.log(DataEntity.schema) * @description Gets the data schema related to this Entity Data API * @return {object} this.#_schema */ get schema () { return this.#_schema } /** * @memberof DataEntity * @member {getter} DataEntity.strategy * @example console.log(DataEntity.strategy) * @description Gets the data strategy currently being used * @return {string} this.#_strategy */ get strategy () { return this.#_strategy } /** * @Method DataEntity.Model * @description create a Data Model based on given document * @param {object} doc - A valid document validated against mongoose schema * @param {object} schema - Mongoose based schema * @return {object} model - Mongoose document */ Model(doc, schema) { const modelSystem = mongoose.Document modelSystem.prototype.isNotValid = modelSystem.prototype.validateSync return modelSystem(doc, schema) } /** * @async * @Method DataEntity.add * @description add a new document to the storage * @param {object} doc - A valid document validated against mongoose schema * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Created document * @example const doc = { name: 'Eduardo Almeida', address: 'Av. Beira Mar. Praia do Morro, Guarapari - ES. Brazil.', email: 'web2solucoes@gmail.com', cards: [] } const { data, error } = await Customer.add(doc) */ async add(doc = {}) { if (!(doc instanceof Document)) { // return createMethodSignature('You must pass a valid JSON document as parameter to DataEntity.add() method', null) } if (Object.keys(doc).length &lt; 1) { return createMethodSignature('You must pass a valid JSON document as parameter to DataEntity.add() method', null) } let data = null let error = null let rawObj = {} delete doc.__id delete doc._id try { const model = new this.Model(doc, this.#_schema) const invalid = model.validateSync() if (invalid) { return createMethodSignature(invalid, data) } rawObj = toJSON(model) // console.log('add', rawObj) const __id = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .add({ ...rawObj }) data = { __id, ...rawObj } } catch (e) { error = e } this.#_triggerAddEvents({ data, error, primaryKey: data.__id, rawObj }) return createMethodSignature(error, data) } /** * @Method DataEntity.#_triggerAddEvents * @description PRIVATE - Triggers all events related to 'add document' event * @param {object} eventPayload - Object containing all information about the event * @param {object} eventPayload.data - The new document inserted into database, default is null if not provided * @param {object|string} eventPayload.error - The returned error from database add request if any, default is null if not provided * @param {number} eventPayload.primaryKey - The primaryKey value of the added document, default is zero if not provided * @param {object} eventPayload.rawObj - The raw document object provided on dataEntity.add(doc) mehod call. Default is {} if not provided. */ #_triggerAddEvents({ data = null, error = null, primaryKey = 0, rawObj = {} } = {}) { const action = 'add' this.#_foundation.triggerEvent(`collection:${action}:${this.#_entity.toLowerCase()}`, { foundation: this.#_foundation, entity: this.#_entity, document: rawObj, primaryKey, data, error, }) this.triggerEvent(action, { foundation: this.#_foundation, entity: this.#_entity, document: rawObj, primaryKey, data, error, }) const state = { action, data, error, document: rawObj, primaryKey } this.#_sendStateChangeToAllOtherSessions(state) } /** * @async * @Method DataEntity.edit * @description Edit a document on the storage * @param {string|number} primaryKey - The primary key value of the desired document * @param {object} doc - A valid document validated against mongoose schema * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Edited document * @example const doc = { __id: 1, _id: '601cb8d8623dc60000ee3c24', name: 'Eduardo Almeida', address: 'Av. Beira Mar. Praia do Morro, Guarapari - ES. Brazil.', email: 'web2solucoes@gmail.com', cards: [] } const { data, error } = await Customer.edit(doc.__id, doc) */ async edit(primaryKey = null, doc = {}) { if (!(doc instanceof Document)) { // return createMethodSignature('You must pass a valid JSON document as parameter to DataEntity.edit() method', null) } if (Object.keys(doc).length &lt; 1) { return createMethodSignature('You must pass a valid JSON document as parameter to DataEntity.edit() method', null) } if (primaryKey === null) { return createMethodSignature('You must pass a valid primary key value as parameter to DataEntity.edit() method', null) } if (typeof doc.__id !== 'number') { return createMethodSignature('Document must have doc.__id (Integer) when calling DataEntity.edit() method', null) } if (typeof doc._id !== 'string') { return createMethodSignature('Document must have doc._id (ObjectID) when calling DataEntity.edit() method', null) } primaryKey = +primaryKey let data = null let error = null let rawObj = {} try { const model = new this.Model(doc, this.#_schema) const invalid = model.validateSync() if (invalid) { return createMethodSignature(invalid, data) } rawObj = toJSON(model) rawObj.__id = primaryKey const response = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .put({ ...rawObj }) // .update({ __id: primaryKey }, { ...rawObj }) data = { __id: primaryKey, ...rawObj } /* if (response.modifiedCount === 1) { data = { __id: primaryKey, ...rawObj } } else { data = null error = { message: 'Critical query error on update', response } } */ } catch (e) { error = e } this.#_triggerEditEvents({ data, error, primaryKey, rawObj }) return createMethodSignature(error, data) } /** * @Method DataEntity.#_triggerEditEvents * @description PRIVATE - Triggers all events related to 'edit document' event * @param {object} eventPayload - Object containing all information about the event * @param {object} eventPayload.data - The new document updated into database, default is null if not provided * @param {object|string} eventPayload.error - The returned error from database edit request if any, default is null if not provided * @param {number} eventPayload.primaryKey - The primaryKey value of the edited document, default is zero if not provided * @param {object} eventPayload.rawObj - The raw document object provided on dataEntity.edit(primaryKey, doc) mehod call. Default is {} if not provided. */ #_triggerEditEvents({ data = null, error = null, primaryKey = 0, rawObj = {} } = {}) { const action = 'edit' this.#_foundation.triggerEvent( `collection:${action}:${this.#_entity.toLowerCase()}`, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, document: rawObj, data, error } ) this.triggerEvent( action, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, document: rawObj, data, error } ) const state = { action, data, error, document: rawObj, primaryKey } this.#_sendStateChangeToAllOtherSessions(state) } /** * @async * @Method DataEntity.delete * @description delete a document from the storage * @param {string|number} primaryKey - The primary key value of the desired document * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Deleted document */ async delete(primaryKey) { primaryKey = +primaryKey let data = null let error = null let rawObj = {} try { const __id = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .delete(primaryKey) // console.error({ __id }) data = { __id: primaryKey } } catch (e) { error = e } this.#_triggerDeleteEvents({ data, error, primaryKey }) return createMethodSignature(error, data) } /** * @Method DataEntity.#_triggerDeleteEvents * @description PRIVATE - Triggers all events related to 'delete document' event * @param {object} eventPayload - Object containing all information about the event * @param {object} eventPayload.data - A object containing the __id property of the deleted document, default is null if not provided * @param {object|string} eventPayload.error - The returned error from database edit request if any, default is null if not provided * @param {number} eventPayload.primaryKey - The primaryKey value of the deleted document, default is zero if not provided */ #_triggerDeleteEvents({ data = null, error = null, primaryKey = 0 } = {}) { const action = 'delete' this.#_foundation.triggerEvent( `collection:${action}:${this.#_entity.toLowerCase()}`, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, data, error } ) this.triggerEvent( action, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, data, error } ) const state = { action, data, error, primaryKey } this.#_sendStateChangeToAllOtherSessions(state) } /** * @async * @Method DataEntity.findById * @description find a document from the storage by ID * @param {string|number} primaryKey - The primary key value of the desired document * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Found document */ async findById (primaryKey) { let data = null let error = null try { primaryKey = parseInt(primaryKey) const doc = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .get(primaryKey) // console.log({ __id: primaryKey, doc }) if (doc) { if (doc.__id === primaryKey) { data = { __id: primaryKey, ...doc } } } } catch (e) { error = e } return createMethodSignature(error, data) } /** * @async * @Method DataEntity.findAll * @summary Find all documents * @description This method will to return all documents based on the given query. If no query is specified, it will returns all records from this collection * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {array} signature.data - Array of Found documents */ async findAll(query = {}) { let data = null let error = null try { const documents = await this.#_foundation .localDatabaseTransport .collection(this.#_entity) .find(query) .toArray() data = documents } catch (e) { error = e } return createMethodSignature(error, data) } /** * @async * @Method DataEntity.find * @summary find documents based on the given query and returns a paginated response * @description This method will to return the documents based on the given query and the specified paging. If no query is specified, it will returns documents based on paging only. * @param {object|null} query - The query object to search documents * @param {object} pagination - Pagination object. If not provided will assume internaly set pagination. * @param {number} pagination.offset - Offset. Default 0. * @param {number} pagination.limit - Limit. Default 30. * @example User.find({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {array} signature.data - Array of Found documents */ async find(query = {}, pagination = this.#_pagination) { let { offset, limit } = pagination let data = null let error = null try { const documents = await this.#_foundation .localDatabaseTransport .collection(this.#_entity) .find(query) .reverse() .offset(offset) .limit(limit) .toArray() data = documents } catch (e) { error = e } return createMethodSignature(error, data) } /** * @async * @Method DataEntity.count * @description count all documents based on the given query * @param {object} query - The query object to count documents * @example User.count({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {number} signature.data - Documents counter */ async count (query = {}) { let data = null let error = null try { const counter = await this.#_foundation .localDatabaseTransport .collection(this.#_entity) .count(query) data = counter } catch (e) { error = e } return createMethodSignature(error, data) } /** * @Method DataEntity.#_listenToAllOtherSessionsStateChanges * @summary PRIVATE - Listen to data state changes on every Application session. * @description Listen to data state change event incoming from every other Application session and communicates to every subscriber tied to this session. * &lt;br&gt;&lt;br&gt; The application scope is the browser running the application. * &lt;br&gt;&lt;br&gt; Every tab is considered a session. * &lt;br&gt; &lt;br&gt; Internally it triggers all events related to data change events, except if the source, the session which originated the event, is the same that is receiving the event * &lt;br&gt; &lt;br&gt; It does not rely on network to propagate the changes. * @example this.#_listenToAllOtherSessionsStateChanges() */ #_listenToAllOtherSessionsStateChanges() { window.addEventListener('storage', (event) =&gt; { if (event.key === this.#_stateChangeStorageName) { const { key, newValue, oldValue } = event if (newValue) { // console.log('DATAAPI -&gt; got new state change', { key, newValue, oldValue }) const jsonState = JSON.parse(newValue) const { error, data, entity, action, source, document } = jsonState // console.error({ error, data, entity, action, source, document }) const eventObj = { foundation: this.#_foundation, entity: entity, document: document, data, error } this.#_foundation.triggerEvent(`collection:${action}:${entity.toLowerCase()}`, eventObj) this.triggerEvent(action, eventObj) } // oldValue } }) } /** * @Method DataEntity.#_sendStateChangeToAllOtherSessions * @summary PRIVATE - Sends data state changes information to every other current application session. * @description The application scope is the browser running the application. &lt;br&gt; Every tab is considered a session.&lt;br&gt; It can not rely on network. * @param {object} state - Object containing all information about the state * @param {object} state.data - The modified data, default is null if not provided * @param {object|string} state.error - The returned error when trying to modify the data, default is null if not provided * @param {object} state.document - The raw object used as value to get the new data state, default is {} if not provided * @example this.#_sendStateChangeToAllOtherSessions({ action: 'add', data: {...newDocument}, error: null, document: {...originalDocument} }) */ #_sendStateChangeToAllOtherSessions(state = { action: '', data: null, error: null, document: {} }) { state.source = { sessionId: this.#_foundation.tabId, applicationId: this.#_foundation.guid, } state.entity = this.#_entity const stateChange = JSON.stringify(state) window.localStorage.setItem(this.#_stateChangeStorageName, stateChange) window.localStorage.removeItem(this.#_stateChangeStorageName) } } × Search results Close Sponsored by WEB2 Solutions "},"Foundation.js.html":{"id":"Foundation.js.html","title":"Source: Foundation.js","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Source: Foundation.js /* global localStorage, navigator, window */ import { createMethodSignature, uuid, Schema } from './utils' import DataEntity from './DataEntity' import LocalDatabaseTransport from './LocalDatabaseTransport' import EventSystem from './EventSystem' // import workerOnMessage from './events/workerOnMessage' /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class Foundation * @description Foundation boostrap class * @extends EventSystem * @param {object} config - Foundation configuration * @param {string} config.name - Foundation name * @param {string} config.dataStrategy - Data strategy. Recognized values: offlineFirst, onlineFirst, offline, online * @param {boolean} config.useWorker - Use a ServiceWorker in Background * @param {object} config.schemas - map of data schemas * @example {@lang javascript} // =========&gt; main.js // import React import React from 'react' import ReactDOM from 'react-dom' // import Bootstrap import 'bootstrap/dist/css/bootstrap.css' // import React app import App from './App' // import agnostic foundation foundation class import Foundation from './foundation/Foundation' const CustomerSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const OrderSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, shipTo: { type: String, required: true, index: true }, paymentMethod: { type: String, required: true, index: true }, amount: { type: Number, required: true, default: 0, index: true }, date: { type: Date, default: Date.now, index: true } }) const ProductSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new Foundation.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Foundation({ name: 'My App', useWorker: true, dataStrategy: 'offline', schemas: { User: UserSchema, Product: ProductSchema, Order: OrderSchema, Customer: CustomerSchema } }) foundation.on('foundation:start', async function(eventObj) { const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start foundation and get it ready to be used await foundation.start() const start = await foundation.start() if (start.error) { throw new Error(`Error starting foundation stack: ${start.error}`) } // console.debug('start', start) ReactDOM.render( &lt;App foundation={foundation} /&gt;, document.getElementById('root') ) */ export default class Foundation extends EventSystem { #_schemas #_name #_dataStrategy #_started #_models #_guid #_useWorker #_workers #_tabId constructor ({ name = 'My Foundation Name', dataStrategy = 'offline', useWorker = false, schemas = {} } = {}) { super() this.#_name = name this.#_dataStrategy = dataStrategy this.#_useWorker = useWorker this.#_schemas = schemas this.#_started = false this.#_guid = uuid() this.#_models = {} this.#_useWorker = useWorker || false this.#_workers = {} this.localDatabaseTransport = new LocalDatabaseTransport() this.#_tabId = uuid() // assume new Id on every refresh } /** * @member {getter} Foundation.dataStrategy * @Description Get the data strategy being used.&lt;br&gt; Possible values are: offlineFirst, onlineFirst, offline, online. &lt;br&gt; Default: offlineFirst * @example console.log(Foundation.dataStrategy) * @return {string} this.#_dataStrategy */ get dataStrategy () { return this.#_dataStrategy } /** * @member {getter} Foundation.guid * @description Get the Foundation Session guid currently being used. * @example console.log(Foundation.guid) */ get guid () { return this.#_guid } /** * @member {getter} Foundation.data * @description Get the Foundation data API(DataEntity) * @example const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug(Eduardo) // { // data: {__id: 1, _id: \"600e0ae8d9d7f50000e1444b\", name: \"Eduardo Almeida\", username: \"web2\", id: \"600e0ae8d9d7f50000e1444b\"} // error: null // } */ get data() { return this.#_models } /** * @member {getter} Foundation.tabId * @description Get the Browser tab ID * @example console.log(foundation.tabId) */ get tabId() { return this.#_tabId } /** * @member {getter} Foundation.name * @name Foundation.name * @description Get the Foundation name * @example console.log(Foundation.name) */ get name () { return this.#_name } /** * @member {setter} Foundation.name * @name Foundation.name * @description Set the Foundation name * @example Foundation.name = 'Provide the name here' * @param {string} name - Foundation name */ set name (name) { this.#_name = name } /** * @member {getter} Foundation.started * @description Get the start state * @example console.log(Foundation.started) */ get started () { return this.#_started } /** * @memberof Foundation * @member {getter} Foundation.applicationWorker * @example Foundation.applicationWorker.postMessage() * @description Get the Foundation worker */ get applicationWorker() { return this.#_workers.foundation } /** * @Method Foundation.mapToDataEntityAPI * @summary Maps an Data Entity abstraction to foundation Data API * @description An Data Entity abstraction is an instance of the {@link DataEntity}. * Once it is mapped to foundation Data API, you can reach every Data Entity in the system from a single source point. * This method dont works as expected if you call it after {@link Foundation.start} method. * See {@link Foundation.importDataEntity} for usage further information. * @param {string} entity - Data Entity name * @param {dataEntity} dataEntity - An {@link DataEntity} instance */ mapToDataEntityAPI(entity = '', dataEntity = {}) { let _error = null let _data = null // if call mapToDataEntityAPI('Product') more than once, it will ovewrite the previous set Product model this.#_models[entity] = dataEntity _data = this.#_models[entity] return createMethodSignature(_error, _data) } /** * @memberof Foundation * @member {getter} Foundation.Schema * @example new Foundation.Schema({}) * @description Creates new data schema * @returns schema creator */ static get Schema() { return Schema } /** * @Method Foundation.importDataEntity * @summary Alias to Foundation.mapToDataEntityAPI(entity = '', dataEntity = {}) * @description An Data Entity abstraction is an instance of the {@link DataEntity}. * Once it is mapped to foundation Data API, you can reach every Data Entity in the system from a single source point. * This method dont works as expected if you call it after {@link Foundation.start} method * @param {object} spec - Data Entity abstraction specification * @param {string} spec.entity - Data Entity name * @param {dataEntity} spec.dataEntity - An {@link DataEntity} instance for the entity defined on `spec.entity` * @example const productSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price: { type: Number, required: true, index: true } }) // start the foundation const foundation = new Foundation({ name: 'My Test app', schemas: { // Customer: schema } }) // Build a customized Data Entity abstraction const MyCustomizedDataEntity = class extends DataEntity { constructor (config) { super(config) } sell (primaryKey, orderId) { // primaryKey is Product primary key value // orderId is the primaryKey of an Order // const foundOrder = await Order.findById(orderId) // if (foundOrder.error) { // CAN NOT TO SELL // } // const items = foundOrder.data.lineItems.filter(i =&gt; (i.productId === primaryKey)) // If Order has the product listed item // if(items[0]) // { // await this.delete(primaryKey) // deletes a Product from Products // } } } // instance of the custimized Data Entity const productDataEntity = new MyCustomizedDataEntity({ foundation, entity: 'Product', schema: productSchema }) // import data entity foundation.importDataEntity({ entity: 'Product', dataEntity: productDataEntity }) // start the foundation await foundation.start() // you can now do things like: const { Product } = foundation.data await Product.add({ name: 'Big Mac', vendor: 'McDonalds', price: 3 }) */ importDataEntity({ entity = null, dataEntity = {} }) { this.mapToDataEntityAPI(entity, dataEntity) } #mapModels(schemas) { let _error = null let _data = null try { for (const entity in schemas) { if (Object.prototype.hasOwnProperty.call(schemas, entity)) { // console.debug('for (const entity in schemas)', entity) const strategy = 'offlineFirst' const schema = schemas[entity] const dataEntity = new DataEntity({ foundation: this, entity, strategy, schema }) this.mapToDataEntityAPI(entity, dataEntity) } } _data = this.#_models } catch (error) { console.error(error) _error = error } return createMethodSignature(_error, _data) } /** * @member {getter} Foundation.useWorker * @Description flag if is there ServiceWorker being used * @return {boolean} */ get useWorker () { return this.#_useWorker } /** * @Method Foundation.setGuidStorage * @description save Foundation uuid to localStorage * @param {string} guid * @return Foundation uuid saved on localStorage */ setGuidStorage (guid) { window.localStorage.setItem('guid', guid) return window.localStorage.getItem('guid') } /** * @Method Foundation.setupAppGuid * @description check if Foundation has a uuid saved o * @return Foundation uuid saved on localStorage */ setupAppGuid () { const guidCache = window.localStorage.getItem('guid') || false if (guidCache) { this.#_guid = guidCache } else { this.setGuidStorage(this.#_guid) } return window.localStorage.getItem('guid') } /** * @async * @Method Foundation.#registerApplicationWorker * @description Setup and Register the main Service worker used by foundation core * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Worker Registration Object */ /* #registerApplicationWorker (workerFile = 'ServiceWorker.js') { const self = this return new Promise((resolve, reject) =&gt; { if ('serviceWorker' in navigator) { navigator.serviceWorker .register('/' + workerFile, { // scope: '/' }) .then(function (reg) { // registration worked navigator.serviceWorker.addEventListener('message', workerOnMessage.bind(self)) if (reg.installing) { self.#_workers['foundation'] = reg.installing self.#_workers['foundation'].postMessage({ cmd: 'getClientId', message: null }) } else if (reg.active) { self.#_workers['foundation'] = reg.active self.#_workers['foundation'].postMessage({ cmd: 'getClientId', message: null }) } resolve(createMethodSignature(null, reg)) }) .catch(function (error) { // registration failed resolve(createMethodSignature(error, null)) }) } }) } */ /** * @async * @Method Foundation.#registerWorker * @description Setup and Register a Service worker and get it ready for usage into your application scope * @param {string} name - Worker name. Used to access it from the namespace * @param {string} workerFile - Worker file name * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Worker Registration Object */ /* #registerWorker (name = '', workerFile = 'ServiceWorker.js') { const self = this return new Promise((resolve, reject) =&gt; { if ('serviceWorker' in navigator) { navigator.serviceWorker .register('/' + workerFile, { // scope: '/' }) .then(function (reg) { // registration worked navigator.serviceWorker.addEventListener('message', workerOnMessage.bind(self)) if (reg.installing) { self.#_workers[name] = reg.installing self.#_workers[name].postMessage({ cmd: 'getClientId', message: null }) } else if (reg.active) { self.#_workers[name] = reg.active self.#_workers[name].postMessage({ cmd: 'getClientId', message: null }) } resolve(createMethodSignature(null, reg)) }) .catch(function (error) { // registration failed resolve(createMethodSignature(error, null)) }) } }) } */ /** * @Private * @description Starts foundation stack required items * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Foundation data */ async #startVitals () { let _error = null let _data = null try { this.setupAppGuid() const mapModels = this.#mapModels(this.#_schemas) await this.localDatabaseTransport.connect() // start database // start all here _data = { status: { mapModels } } } catch (error) { console.error(error) _error = error } this.triggerEvent('foundation:startVitals', { foundation: this, error: _error, data: _data }) return createMethodSignature(_error, _data) } /** * @async * @Method Foundation.start * @description Starts foundation stack and get it ready to use. &lt;br&gt; it calls this.#startVitals() internally * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Foundation data */ async start () { let _error = null let _data = null try { const vitals = await this.#startVitals() // if (this.useWorker) { // await this.#registerApplicationWorker() // } this.#_started = true _data = { ...vitals.data, started: this.#_started } } catch (error) { console.error(error) _error = error } this.triggerEvent('foundation:start', { foundation: this, error: _error, data: _data }) // console.warn('STARTED&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;', this) return createMethodSignature(_error, _data) } } × Search results Close Sponsored by WEB2 Solutions "},"LocalDatabaseTransport.js.html":{"id":"LocalDatabaseTransport.js.html","title":"Source: LocalDatabaseTransport.js","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Source: LocalDatabaseTransport.js import dexie from 'dexie' import 'dexie-mongoify' import { createMethodSignature, mongooseToDexieTableString } from './utils' dexie.debug = true /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class LocalDatabaseTransport * @description Database transport for IndexedDB * @extends dexie * @see The Data Transport is set into the {@link Foundation} stack and it is consumed inside {@link DataEntity} to persist data locally. * @see {@link LocalDatabaseTransport} extends {@link https://dexie.org/docs/Dexie/Dexie|Dexie} as database handler for IndexedDB. See {@link https://dexie.org/docs/Dexie/Dexie|Dexie} * @param {object} config - Transport configuration * @param {number} config.version - Database version. &lt;br&gt;Same as IndexedDB database version. * @param {object} config.tables - Database tables. &lt;br&gt;Dexie tables configuration. * @param {string} config.dbName - Database name. &lt;br&gt;Same as IndexedDB database name. * @example {@lang javascript} import LocalDatabaseTransport from './LocalDatabaseTransport' import { Schema } from './utils' const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const ProductSchema = new Schema({ // ... }) const dbName = 'MyDatabaseName' const localDataTransport = new LocalDatabaseTransport({ version: 1, // default 1 tables: {}, // default {} dbName }) // or const localDataTransport = new LocalDatabaseTransport({ dbName }) localDataTransport.addSchema('User', UserSchema) localDataTransport.addSchema('Product', ProductSchema) await localDataTransport.connect() const Biden = await localDataTransport.table('User').add({ name: 'Joe Biden', username: 'biden'}) const Ferrari = await localDataTransport.table('Product').add({ name: 'Ferrari', vendor: 'Ferrari', price_cost: 3000000}) */ export default class LocalDatabaseTransport extends dexie { #_version #_tables #_connected #_schemas #_dbName constructor ({ version = 1, tables = {}, dbName = 'DatabaseName' } = {}) { // console.error('STARTED LocalDatabaseTransport') // run the super constructor Dexie(databaseName) to create the IndexedDB // database. super(dbName) this.#_dbName = dbName this.#_version = version this.#_tables = tables this.#_connected = false this.#_schemas = {} } #_setTables() { for (const entity in this.#_schemas) { if (Object.prototype.hasOwnProperty.call(this.#_schemas, entity)) { // console.error(entity) this.#_tables[entity] = mongooseToDexieTableString( this.#_schemas[entity] ) } } } /** * @Method LocalDatabaseTransport.addSchema * @description A a Data Schema into the Schema tree * @param {string} schemaName - The schema name. Same as Entity name. * @param {object} schema - A valid mongoose like schema * @example const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) localDataTransport.addSchema('User', UserSchema) * @return {object} schema - The schema enty from inside the Schema tree */ addSchema (schemaName, schema) { this.#_schemas[schemaName] = schema return this.#_schemas[schemaName] } /** * @async * @Method LocalDatabaseTransport.connect * @description Setup connection to local database * @return Foundation uuid saved on localStorage * @example await localDataTransport.connect() * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error information * @return {object} signature.data - Connection information */ async connect() { let error = null let data = null try { this.#_setTables() this .version(this.#_version) .stores(this.#_tables) // for (const tableName in this.#_tables) { // this[tableName] = this.table(tableName) // } const open = await this.open() data = open } catch (e) { error = e data = null } return createMethodSignature(error, data) } } × Search results Close Sponsored by WEB2 Solutions "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Source: utils.js /* global lunr */ import lunr from 'lunr' import mongoose from 'mongoose' // const lunr = require('lunr') // console.debug('&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;', lunr) /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @module utils * */ /** * createMethodSignature * Create default signature method object * @function * @param {string|object} error - The string or error object if have any * @param {object|array|number|string|boolean} data - Information about method execution * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object|array|number|string|boolean} signature.data - Execution data */ export const createMethodSignature = (error = null, data = null) =&gt; { return { error, data } } /** * uuid * generates a Universally unique identifier string * @function * @return {string} guid / uuid */ export function uuid () { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { const r = (Math.random() * 16) | 0 const v = c === 'x' ? r : (r &amp; 0x3) | 0x8 return v.toString(16) }) } /** * toJSON - stringify and parse an object&lt;br&gt; It uses native JSON internally. * @function * @param {string|object} obj - Valid JSON object or string * @return {object} new JSON object */ export function toJSON (obj = '') { if (typeof obj === 'string') { return JSON.parse(obj) } return JSON.parse(JSON.stringify(obj)) } /** * mongooseToDexieTableString * convert given Mongoose schema to a Dexie Table columns configuration. &lt;br&gt; * All columns inside returned configuration are indexed at IndexedDB * prepend __id as local primary key and _id for remote primary key * Local primary key is integer and auto incremented * @function * @return {string} Dexie table configuration string */ export function mongooseToDexieTableString (schema) { const cols = [] for (let propertyName in schema.paths) { if (Object.prototype.hasOwnProperty.call(schema.paths, propertyName)) { const property = schema.paths[propertyName] console.debug(property) const { instance, // instance is type _index, // , options, // { default, index, required } // isRequired } = property // console.debug(propertyName, property) if (propertyName === '_id' || propertyName === '__id') { continue } if (!_index) { continue } if (instance === 'Array') { propertyName = `*${propertyName}` // * is MultiEntry Index on Dexie } // if unique cols.push(propertyName) } } return `++__id,_id${cols.length &gt; 0 ? (',' + cols.join(',')) : ''}` } /** * getSearchTokenStream * generates a lunr search token. See {@link https://lunrjs.com/guides/searching.html|lunr search} * @function * @return {array} token */ export function getSearchTokenStream(text = '') { // console.log('xxxxxxxxx') // console.log('xxxxxxxxx', index) // const index = lunr() // return index.pipeline.run(lunr.tokenizer(text)) const token = (lunr.tokenizer(text)).map(t =&gt; (t.str)) return token // return lunr.tokenizer(text) } export const Schema = mongoose.Schema × Search results Close Sponsored by WEB2 Solutions "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Modules Classes DataEntity Data Entity API Foundation Foundation boostrap class. LocalDatabaseTransport Database transport for IndexedDB. × Search results Close Sponsored by WEB2 Solutions "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Classes Classes DataEntity Data Entity API Foundation Foundation boostrap class. LocalDatabaseTransport Database transport for IndexedDB. × Search results Close Sponsored by WEB2 Solutions "},"index.html":{"id":"index.html","title":"Index","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport | | | | | VooduX Summary The VooduX's proposal is to cover the common lacks and mistakes in modern web applications development. It heavly opinionate on how to define a strong underlying architecture for the most common types of web softwares which relies mostly in V-* like libraries and frameworks such as Vue and React. What VooduX is not? It does not replace Redux, Mobx, Vuex any any other kind of Application Management abstraction. It does not cares about how you manage your application state. It does not cares about which project standard's framework/library you employ. Vue, React, It does not matters. It does not cares about the UI framework/library you are employing. The Material UI, Boostrap, Vuetify, Sencha, DHTMLX, Dojo. What is VooduX then? It is good to see teams proud of being TDD driven teams. It is amazing to see team proud of Translating pixel-perfect designs from Figma, it is really are fascinating to be exposed to new and good User Xperiences. Horses flying and 3D rotating on screen, big red error messages on giant rounded number form field when user tries to type a string value inside, are good, but this is the head of the iceberg only. In several cases, industries are heavily focusing on specific pieces of the process, under a totaly focused on a Software Engineering field influenced perspective, rather than prior scoping a overall product plan, flavoured on a System Information field perspective. Sometimes part of the project process is rock solid, but the final product is lacking in simple things. I saw large financial applications that when opened on multiple browser tabs, and if you add a new data in tab one, all other tabs stays dumb. If I went to another tab, the new data was not there. We really love State Management libraries and we use them on daily basis. But we don't agree to the assumption that Application State Management does the same as a Application Data Management abstraction suposedly does. Simply because the application data size might considerable grows. We like to think in a scenario where the Application State Management abstraction handles pieces of data that are curenlty being used in the screen at the present moment. But it does not means you should not have another pieces of data being underlying handled by some other manner behind the scenes. Let's make a simple comparison to quickly visualize the main difference between traditional React/Vue applications and a VooduX powered application: This is how a common React/Vue application looks like: This is how a VooduX powered React/Vue application looks like: Please don't get us wrong. We are not reinventing any wheels. We are just leveraging well stabilished paradigms and methodologies like Entity Relationship, Data Entities, Actors, Objects, RAD, Component Engineering, Messaging Patterns, 2-way data flow over an Event Driven Architecture, Data Caching so on and so forth, to delivery agile produced sotware MVPs that scales since from it initial days. Supose the server - back end emits a Server Event Message to connected clients with the following info: { action: 'completed', entity: 'Order', id: 24455, customerId: 3443, lineItems: [...[{}]], totalPaid: 5430 } Supose you are currently catching your eyes at the Dashboard page in the screen where you have: Last Order Listing, Sales Chart and Total Earns Today badge. Like this: You now need to update those components based on the received Server Event Message. The Last Order Listing component displays the name of the customer alongside it address and total paid for that specific order. In that moment, if you dont have the Customer information inside the Application State Management implementation, you need to get it in another place. That is where the Application Data Management abstraction resides. Traditionaly the main applications implementation rely on directly calling an API, or even use things like the browser localStorage API, which will fails once it data size and complexity grows. Going against this implementation model, we intoduce a proxy like abstraction relying on IndexedDB as local (front end) database, which is a NoSQL database shipped with every modern browser. There are some frameworks, like Backbone, and some plugins for React and Vue that aims to use IndexedDb as database, but they are dumb and lazy in terms of data design driven development and validation. Aditionaly, VooduX abstract some kind of data transporters which is used to send own produced event and data to and to consume thirdy party produced event and data from. Every data change has an associated event object and action, which is not used only for Event Sourcing, but also to provide direct bindings for decoupled View components. Despite the fact we can now fastly and cheaply request data, we have also a complete database running on front end. The Application Data Management abstraction gives you some capabilities such: Do not loose data on network disconnections. 100% offline capable applications. Drastically reduce server resources dependency. High performant UI reactivity. VooduX provides a underlying architecture offering resources like: Generic Data Schema and Data Model driven design. Use the Mongoose implementation to define models. Same model can both run on client and server. A proxy like Data Entity API supporting different data transports Enforced Entity Relatioship and Data Entities design Application session Realtime Data Sync Plugin based Data Transport to give you the freedom to back your web software with any kind of back end technology Trully multi threaded architecture by leveraging web workers. Web applications are originally single threaded applications. 100% offline capable applications Asynchronous and event driven architecture. Data Schema generators leveraging the OpenAPI speficiations (Swagger) as declarative metadata standard CRUD interfaces generators targeting React, Vue, DHTMLX and jQwidgets and leveraging OpenAPI speficiations (Swagger) as declarative metadata standard Install Via npm - Simple usage $ npm install voodux --save Via git - Advanced usage $ git clone https://github.com/web2solutions/voodux.git $ cd voodux $ npm install How to use This the Step by Step guide to use VooduX Importing VooduX into your application The first step to use VooduX in your project it to import it library. ES5 require const { Foundation, // LocalDatabaseTransport, // DataEntity, // utils } = require('voodux/dist/main').default ES6 import We use brand new ES6 features, like privacy on Classes. If you are willing to import our classes into you ES6 project, you must setup the following babel plugins: \"@babel/plugin-transform-runtime\" \"@babel/plugin-proposal-class-properties\" \"@babel/plugin-proposal-private-methods\" Not least, you must use at least the env preset. Then your .babelrc file will looks like the following: { \"presets\": [ \"@babel/preset-env\", \"@babel/preset-react\" ], \"plugins\": [ \"@babel/plugin-transform-runtime\", \"@babel/plugin-proposal-class-properties\", \"@babel/plugin-proposal-private-methods\" ] } Otherwise you are going to face compilation issues. In order to import the main library to your project just simply import it: import { Foundation } from 'voodux' Browser directly usage &lt;script type=\"text/javascript\" src=\"voodux/dist/main.min.js\"&gt;&lt;/script&gt; React and Vue Project Structure This is how a hypotethical React or Vue project structure looks like. This example is assuming the fact that your application have 4 pages: Dashboard Customers Orders Products ├── dist -&gt; Final app code goes here ├── docs │ ├── code -&gt; JSDoc documentation will be saved here │ └── reports -&gt; Karma reports will be saved here ├── html_app -&gt; Original static files ├── test -&gt; Test suites goes here ├── src │ ├── components │ │ ├── customers │ │ │ ├── CustomersAdd.js -&gt; Add form │ │ │ ├── CustomersEdit.js -&gt; Edit form │ │ │ ├── index.js -&gt; Main listing page │ │ │ └── events -&gt; Event Handlers decoupled from component files │ │ ├── dashboard │ │ │ ├── Chart.js -&gt; Finance Chart │ │ │ ├── index.js -&gt; Main listing page │ │ │ └── events -&gt; Event Handlers decoupled from component files │ │ ├── orders │ │ │ ├── OrdersAdd.js -&gt; Add form │ │ │ ├── index.js -&gt; Main listing page │ │ │ └── events -&gt; Event Handlers decoupled from component files │ │ ├── products │ │ │ ├── ProductsAdd.js -&gt; Add form │ │ │ ├── ProductsEdit.js -&gt; Edit form │ │ │ ├── index.js -&gt; Main listing page │ │ │ └── events -&gt; Event Handlers decoupled from component files │ ├── events -&gt; Decoupled Application Event handlers │ ├── schemas -&gt; Data Entity Schemas (or Data Models) are saved here │ ├── App.css │ ├── App.js -&gt; React/Vue Application code │ └── main.js -&gt; Application entry point ├── test ├── .babelrc -&gt; Babel configuration ├── .eslintignore -&gt; eslint ignore rules ├── .eslintrc.json -&gt; eslint configuration ├── .prettierrc -&gt; prettier configuration ├── jsDoc.json -&gt; JSDoc configuration ├── package.json └── webpack.config.js -&gt; webpack configuration Writing your application code The underlying architecture of every VooduX application borns in it Data Design. The VooduX strongly believes that the Data plan and Data design is the first step to take when building successful projects. That is why we start by defining some Data Schemas for the Data entities we have in the system. Every Data entity in the system has it own encapsulated methods to access, handle and notify data changes to every actor listening to it. Schemas must be provided in the foundation constructor or at least pior calling the foundation.start() method. Otherwise it collection will not be created inside the local database. Setup a data schema for a Data Entity Every Data Schema in a VooduX application is set using the Foundation.Schema(schema) static method. The data schemas are set following the Mongoose standard to define schemas. It means you are not repeating yourself when writing data schemas because they targets both the front end and back end. In other words, server and client data are being defined by a single contract. import { Foundation } from 'voodux' const CustomerSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) Foundation constructor The starting point of every voodux application is it Foundation. The application foundation holds things like data definition, data access, data validation, data persistence, data change notification .... Prior starting your React or Vue application code, you must create your application foundation and then to pass it as property to your React or Vue application. The application foundation is set by calling the Foundation constructor. const foundation = new Foundation({ name: 'My App', schemas: { User: UserSchema, Product: ProductSchema, Order: OrderSchema, Customer: CustomerSchema } }) Listening to Application Start event Sometimes you may need to start executing heavy tasks prior start rendering your application screens. For example you could start a data sync process, starting to fill out you local database and in meantime, render a dashboard and start rendering data changes in realtime, as long as they are emitted from the Data Entity abstraction implementation. The foundation:start event listener must be set before calling foundation.start(). Otherwise it will not be triggered. foundation.on('foundation:start', async function(eventObj) { const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) Hypothetical full React app setup demo // import React lib import React from 'react' // import Foundation lib import { Foundation } from 'voodux' // setup Data schemas const CustomerSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const OrderSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, shipTo: { type: String, required: true, index: true }, paymentMethod: { type: String, required: true, index: true }, amount: { type: Number, required: true, default: 0, index: true }, date: { type: Date, default: Date.now, index: true } }) const ProductSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new Foundation.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Foundation({ name: 'My App', useWorker: true, dataStrategy: 'offlineFirst', schemas: { User: UserSchema, Product: ProductSchema, Order: OrderSchema, Customer: CustomerSchema } }) // listen to application start event and add some records to database. foundation.on('foundation:start', async function(eventObj) { const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start application foundation and get it ready to be used const start = await foundation.start() if (start.error) { throw new Error(`Error starting foundation stack: ${start.error}`) } // start rendering yout React application by passing the application foundation as it prop. ReactDOM.render( &lt;App foundation={foundation} /&gt;, document.getElementById('root') ) Hypothetical React Customers Listing component This component does render a list of Customers. On the list, every listed customer has associated delete and update links. The component has an array of customers as main state property. Ok, there is nothing new here! The dirty magic begins when the requirement list starting asking for things like: To be able to show the same data in the screen after browser refreshing and do not call the server API asking for those specific piece of data. Have a reliable and high performance 2-way dataflow model between Application Data Storage and Application State Manager. import React from 'react' import { Link, Redirect } from 'react-router-dom' import { LinkContainer } from 'react-router-bootstrap' import swal from 'sweetalert' /** * event listener triggered every time there is a 'add' type data change in Customer Data Entity */ const handlerOnAddDocEventListener = function (eventObj) { const { error, document, foundation, data } = eventObj if (error) { console.error(`Error adding user: ${error}`) return } console.debug([data, ...this.state.customers]) this.setState({ customers: [data, ...this.state.customers] }) } /** * event listener triggered every time there is a 'edit' type data change in Customer Data Entity */ const handlerOnEditDocEventListener = function (eventObj) { const { data, primaryKey, document, foundation, error } = eventObj if (error) { console.error(`Error updating user: ${error}`) return } const newData = this.state.customers.map((customer) =&gt; { if (customer.__id === primaryKey) { return data } else { return customer } }) console.debug([...newData]) this.setState({ customers: [...newData] }) } /** * event listener triggered every time there is a 'delete' type data change in Customer Data Entity */ const handlerOnDeleteDocEventListener = function (eventObj) { const { error, document, foundation, data } = eventObj if (error) { console.error(`Error deleting user: ${error}`) return } const allCustomers = [...this.state.customers] for (let x = 0; x &lt; allCustomers.length; x++) { const customer = allCustomers[x] if (customer.__id === data.__id) { allCustomers.splice(x) } } this.setState({ customers: allCustomers }) } /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Component Customers * @description React component consuming a Customer Data Entity collection to feed a grid * @extends React.Component */ class Customers extends React.Component { constructor (props) { super(props) /** * Entity name which this component represents to */ this.entity = 'Customer' /** * access to foundation instance */ this.foundation = props.foundation /** * default pagination to list data */ this.pagination = { offset: 0, limit: 30 } /** * component state */ this.state = { customers: [] } this.onAddDocEventListener = null this.onEditDocEventListener = null this.onDeleteDocEventListener = null this.handleDeleteCustomer = this.handleDeleteCustomer.bind(this) } /** * @Method Customers.componentWillUnmount * @summary Called immediately before a component is destroyed. Perform any necessary cleanup in this method, such as cancelled network requests, or cleaning up any DOM elements created in componentDidMount. * @description lets stop listen to Customer Data State Change Events */ componentWillUnmount () { const { Customer } = this.foundation.data /** * Destroy event listeners of this component which are listening to Customer collection * and react to it */ Customer.stopListenTo(this.onAddDocEventListener) Customer.stopListenTo(this.onEditDocEventListener) Customer.stopListenTo(this.onDeleteDocEventListener) } /** * @async * @Method Customers.componentDidMount * @summary Called immediately after a component is mounted. Setting state here will trigger re-rendering. * @description Once component is monted we are now ready to start listen to changes on Customer data entity and get a list of customer in database to fill out the state.customers */ async componentDidMount () { const { Customer } = this.foundation.data // listen to add, edit and delete events on Customer collection // and react to it /** * listen to add Customer Data Entity change event on Data API */ this.onAddDocEventListener = Customer.on('add', handlerOnAddDocEventListener.bind(this)) /** * listen to edit Customer Data Entity change event on Data API */ this.onEditDocEventListener = Customer.on('edit', handlerOnEditDocEventListener.bind(this)) /** * listen to delete Customer Data Entity change event on Data API */ this.onDeleteDocEventListener = Customer.on('delete', handlerOnDeleteDocEventListener.bind(this)) // get Customers on database const customers = await Customer.find({}, { ...this.pagination }) // console.warn(customers) if (customers.data) { this.setState({ customers: customers.data }) } } /** * @Method Customers.handleDeleteCustomer * @summary Event handler that Deletes a customer * @description Once component is monted we are now ready to start listen to changes on Customer data entity and get a list of customer in database to fill out the state.customers * @param {event} event - The HTML event triggered on User interation * @param {number} __id - The primaryKey value of the record willing to be deleted */ /** * @Method Customers.handleDeleteCustomer * @summary handleDeleteCustomer event handle * @description triggered when clicking on delete button */ handleDeleteCustomer (e, ___id) { const { Customer } = this.foundation.data e.preventDefault() swal({ title: 'Are you sure?', text: 'Once deleted, you will not be able to recover this!', icon: 'warning', buttons: true, dangerMode: true }).then(async (willDelete) =&gt; { if (willDelete) { const r = await Customer.delete(___id) if (r.error) { swal('Database error', e.error.message, 'error') return } swal('Poof! The customer has been deleted!', { icon: 'success' }) return &lt;Redirect to='/dashboard' /&gt; } else { swal('The Customer is safe!') } }) } /** * @async * @Method Customers.render * @summary Component render function. * @description Renders a grid of Customers */ render () { return ( &lt;main className='col-md-9 ms-sm-auto col-lg-10 px-md-4 main'&gt; &lt;div className='d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 bcustomer-bottom'&gt; &lt;h1 className='h2'&gt;Customers&lt;/h1&gt; &lt;div className='btn-toolbar mb-2 mb-md-0'&gt; &lt;div className='btn-group me-2'&gt; &lt;LinkContainer to='/CustomersAdd'&gt; &lt;button type='button' className='btn btn-sm btn-outline-secondary'&gt; Add new Customer &lt;/button&gt; &lt;/LinkContainer&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className='table-responsive'&gt; &lt;table className='table table-striped table-sm'&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Address&lt;/th&gt; &lt;th&gt;E-mail&lt;/th&gt; &lt;th align='right'&gt;Cards&lt;/th&gt; &lt;th&gt;-&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {this.state.customers.map((doc) =&gt; ( &lt;tr key={doc.id}&gt; &lt;td&gt;{doc.name}&lt;/td&gt; &lt;td&gt;{doc.address}&lt;/td&gt; &lt;td&gt;{doc.email}&lt;/td&gt; &lt;td align='right'&gt;{doc.cards}&lt;/td&gt; &lt;td&gt; &lt;Link color='primary' to={`/CustomersEdit/${doc.__id}`}&gt;[edit]&lt;/Link&gt; | &lt;a color='primary' href='#' onClick={e =&gt; this.handleDeleteCustomer(e, doc.__id)}&gt;[delete]&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; ))} &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/main&gt; ) } } export default Customers Application demos React demos React Demo app (Functional components) Demo app Demo project Demo documentation: -&gt; TODO React Demo app (Class based components) Demo app Demo project Demo documentation: Vue Demos DHTMLX demos Vanilla JS demos Motivation What motivates this Links and references Useful links Project related resources: API documentation Project repository Unit tests Report Report an issue Reference Knowledge base: PWA - Progressive web applications SPA - Single Page Applications IndexedDB Mongoose Server Side Events Event Sourcing RAD - Rapid application development Case tools Metaprogramming Entity Relationship Model Component Engineering Information Systems and Software Engineering - PDF ToDo REST transport Websocket transport Serverless transport (Firebase) Session layer Event sourcing Vue demo DHTMLX demo VanilaJS demo textual search with lunr. Workbox -&gt; https://developers.google.com/web/tools/workbox/guides/get-started × Search results Close Sponsored by WEB2 Solutions "},"DataEntity.html":{"id":"DataEntity.html","title":"Class: DataEntity","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Class: DataEntity DataEntity new DataEntity(DataEntityConfig) Data Entity API When composing web applications using this library, we strongly believe the data design and plan should be the entry point of your software design. The Entity Relationship diagram shall to be one of the initial documents you should to design before starting to write your software. We assume the Entity Relationship and Data Entity models as technique and paradigm to design the application data. If you have no idea of how agile you could to design your ER diagram, please take a look at some tools like Moon Modeler Every Data Entity in the system has it own encapsulated properties and methods that cares about where entity data is writen to and read from. The DataEntity relies on the application instance (passed to it constructor) to access the available data transports. It means you can not use DataEntity prior starting a data transport layer. This class is not for direct usage in your project, unless you are a core developer or want to understand what happens behind the scenes, you should consider to take a look at the Foundation class. Parameters: Name Type Description DataEntityConfig object Data Entity configuration Properties Name Type Description foundation string Provide Accesss to Foundation scope entity string Data entity name which this dataEntity instance is handling strategy boolean Data transport strategy schema boolean Data schema for this Data Entity abstraction. Do not declare the params __id and _id inside your schemas. Author: Eduardo Perotta de Almeida Source: DataEntity.js, line 7 Example import { Schema } from '../foundation/Foundation' const schema = new Schema({ // do not declare __id // do not declare _id name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const Customer = new DataEntity({ foundation, // Foundation instance, object entity: 'Customer', // entity name, string strategy: 'offline', // data strategy, string schema // data schema, a mongoose like schema }) // listen to add Customer Data event on Data API const onAddDocEventListener = Customer.on( 'add', function(eventObj){ const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // listen to edit Customer Data event on Data API const onEditDocEventListener = Customer.on( 'edit', function (eventObj) { const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // listen to delete Customer Data event on Data API const onDeleteDocEventListener = Customer.on( 'delete', function (eventObj) { const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // Stop to listen to events to avoid memory leak or others kind of problems // like to change the state of an unmounted component. // Do something like this -&gt; before component unmount OR before window unload Customer.stopListenTo(onAddDocEventListener) Customer.stopListenTo(onEditDocEventListener) Customer.stopListenTo(onDeleteDocEventListener) Extends EventSystem Members &lt;static&gt; _pagination :property PRIVATE - default internal paging configuration The default paging configuration is: offset: 0, limit 30. It means it will returns 30 documents starting on index 0. Type: property Source: DataEntity.js, line 142 &lt;static&gt; _schema :property PRIVATE - Holds the data schema for this Data Entity Data schema is a mongoose.Schema implementation Type: property Source: DataEntity.js, line 134 &lt;static&gt; _strategy :property PRIVATE - Holds the data transport strategy for this Data Entity. Default strategy is offline. Possible values are: - offlineFirst Data will be saved on local database first. - onlineFirst Data will be saved on remote database first. - offline Data will be saved on local database only. - online Data will be saved on remote database only. Type: property Source: DataEntity.js, line 117 &lt;static&gt; entity :getter Gets the entity name which which DataEntity instance is handling out. Gets the entity name which which DataEntity instance is handling out Type: getter Source: DataEntity.js, line 159 Example console.log(DataEntity.entity) &lt;static&gt; schema :getter Gets the data schema related to this Entity Data API. Gets the data schema related to this Entity Data API Type: getter Source: DataEntity.js, line 170 Example console.log(DataEntity.schema) &lt;static&gt; strategy :getter Gets the data strategy currently being used. Gets the data strategy currently being used Type: getter Source: DataEntity.js, line 181 Example console.log(DataEntity.strategy) Methods &lt;static&gt; _listenToAllOtherSessionsStateChanges() PRIVATE - Listen to data state changes on every Application session. Listen to data state change event incoming from every other Application session and communicates to every subscriber tied to this session. The application scope is the browser running the application. Every tab is considered a session. Internally it triggers all events related to data change events, except if the source, the session which originated the event, is the same that is receiving the event It does not rely on network to propagate the changes. Source: DataEntity.js, line 572 Example this.#_listenToAllOtherSessionsStateChanges() &lt;static&gt; _sendStateChangeToAllOtherSessions(state) PRIVATE - Sends data state changes information to every other current application session. The application scope is the browser running the application. Every tab is considered a session. It can not rely on network. Parameters: Name Type Description state object Object containing all information about the state Properties Name Type Description data object The modified data, default is null if not provided error object | string The returned error when trying to modify the data, default is null if not provided document object The raw object used as value to get the new data state, default is {} if not provided Source: DataEntity.js, line 609 Example this.#_sendStateChangeToAllOtherSessions({ action: 'add', data: {...newDocument}, error: null, document: {...originalDocument} }) &lt;static&gt; _triggerAddEvents(eventPayload) PRIVATE - Triggers all events related to 'add document' event. PRIVATE - Triggers all events related to 'add document' event Parameters: Name Type Description eventPayload object Object containing all information about the event Properties Name Type Description data object The new document inserted into database, default is null if not provided error object | string The returned error from database add request if any, default is null if not provided primaryKey number The primaryKey value of the added document, default is zero if not provided rawObj object The raw document object provided on dataEntity.add(doc) mehod call. Default is {} if not provided. Source: DataEntity.js, line 254 &lt;static&gt; _triggerDeleteEvents(eventPayload) PRIVATE - Triggers all events related to 'delete document' event. PRIVATE - Triggers all events related to 'delete document' event Parameters: Name Type Description eventPayload object Object containing all information about the event Properties Name Type Description data object A object containing the __id property of the deleted document, default is null if not provided error object | string The returned error from database edit request if any, default is null if not provided primaryKey number The primaryKey value of the deleted document, default is zero if not provided Source: DataEntity.js, line 418 &lt;static&gt; _triggerEditEvents(eventPayload) PRIVATE - Triggers all events related to 'edit document' event. PRIVATE - Triggers all events related to 'edit document' event Parameters: Name Type Description eventPayload object Object containing all information about the event Properties Name Type Description data object The new document updated into database, default is null if not provided error object | string The returned error from database edit request if any, default is null if not provided primaryKey number The primaryKey value of the edited document, default is zero if not provided rawObj object The raw document object provided on dataEntity.edit(primaryKey, doc) mehod call. Default is {} if not provided. Source: DataEntity.js, line 354 &lt;async, static&gt; add(doc) add a new document to the storage. add a new document to the storage Parameters: Name Type Description doc object A valid document validated against mongoose schema Source: DataEntity.js, line 204 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Created document Type object Example const doc = { name: 'Eduardo Almeida', address: 'Av. Beira Mar. Praia do Morro, Guarapari - ES. Brazil.', email: 'web2solucoes@gmail.com', cards: [] } const { data, error } = await Customer.add(doc) &lt;async, static&gt; count(query) count all documents based on the given query. count all documents based on the given query Parameters: Name Type Description query object The query object to count documents Source: DataEntity.js, line 544 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Documents counter Type number Example User.count({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) &lt;async, static&gt; delete(primaryKey) delete a document from the storage. delete a document from the storage Parameters: Name Type Description primaryKey string | number The primary key value of the desired document Source: DataEntity.js, line 391 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Deleted document Type object &lt;async, static&gt; edit(primaryKey, doc) Edit a document on the storage. Edit a document on the storage Parameters: Name Type Description primaryKey string | number The primary key value of the desired document doc object A valid document validated against mongoose schema Source: DataEntity.js, line 285 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Edited document Type object Example const doc = { __id: 1, _id: '601cb8d8623dc60000ee3c24', name: 'Eduardo Almeida', address: 'Av. Beira Mar. Praia do Morro, Guarapari - ES. Brazil.', email: 'web2solucoes@gmail.com', cards: [] } const { data, error } = await Customer.edit(doc.__id, doc) &lt;async, static&gt; find(query, pagination) find documents based on the given query and returns a paginated response This method will to return the documents based on the given query and the specified paging. If no query is specified, it will returns documents based on paging only. Parameters: Name Type Description query object | null The query object to search documents pagination object Pagination object. If not provided will assume internaly set pagination. Properties Name Type Description offset number Offset. Default 0. limit number Limit. Default 30. Source: DataEntity.js, line 507 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Array of Found documents Type array Example User.find({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) &lt;async, static&gt; findAll() Find all documents This method will to return all documents based on the given query. If no query is specified, it will returns all records from this collection Source: DataEntity.js, line 482 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Array of Found documents Type array &lt;async, static&gt; findById(primaryKey) find a document from the storage by ID. find a document from the storage by ID Parameters: Name Type Description primaryKey string | number The primary key value of the desired document Source: DataEntity.js, line 452 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Found document Type object &lt;static&gt; Model(doc, schema) create a Data Model based on given document. create a Data Model based on given document Parameters: Name Type Description doc object A valid document validated against mongoose schema schema object Mongoose based schema Source: DataEntity.js, line 192 Returns: model - Mongoose document Type object × Search results Close Sponsored by WEB2 Solutions "},"Foundation.html":{"id":"Foundation.html","title":"Class: Foundation","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Class: Foundation Foundation new Foundation(config) Foundation boostrap class. Foundation boostrap class Parameters: Name Type Description config object Foundation configuration Properties Name Type Description name string Foundation name dataStrategy string Data strategy. Recognized values: offlineFirst, onlineFirst, offline, online useWorker boolean Use a ServiceWorker in Background schemas object map of data schemas Author: Eduardo Perotta de Almeida Source: Foundation.js, line 9 Example // =========&gt; main.js // import React import React from 'react' import ReactDOM from 'react-dom' // import Bootstrap import 'bootstrap/dist/css/bootstrap.css' // import React app import App from './App' // import agnostic foundation foundation class import Foundation from './foundation/Foundation' const CustomerSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const OrderSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, shipTo: { type: String, required: true, index: true }, paymentMethod: { type: String, required: true, index: true }, amount: { type: Number, required: true, default: 0, index: true }, date: { type: Date, default: Date.now, index: true } }) const ProductSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new Foundation.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Foundation({ name: 'My App', useWorker: true, dataStrategy: 'offline', schemas: { User: UserSchema, Product: ProductSchema, Order: OrderSchema, Customer: CustomerSchema } }) foundation.on('foundation:start', async function(eventObj) { const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start foundation and get it ready to be used await foundation.start() const start = await foundation.start() if (start.error) { throw new Error(`Error starting foundation stack: ${start.error}`) } // console.debug('start', start) ReactDOM.render( &lt;App foundation={foundation} /&gt;, document.getElementById('root') ) Extends EventSystem Members &lt;static&gt; applicationWorker :getter Get the Foundation worker. Get the Foundation worker Type: getter Source: Foundation.js, line 276 Example Foundation.applicationWorker.postMessage() &lt;static&gt; data :getter Get the Foundation data API(DataEntity). Get the Foundation data API(DataEntity) Type: getter Source: Foundation.js, line 217 Example const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug(Eduardo) // { // data: {__id: 1, _id: \"600e0ae8d9d7f50000e1444b\", name: \"Eduardo Almeida\", username: \"web2\", id: \"600e0ae8d9d7f50000e1444b\"} // error: null // } &lt;static&gt; dataStrategy :getter Get the data strategy being used. Get the data strategy being used. Possible values are: offlineFirst, onlineFirst, offline, online. Default: offlineFirst Type: getter Source: Foundation.js, line 198 Example console.log(Foundation.dataStrategy) &lt;static&gt; guid :getter Get the Foundation Session guid currently being used. Get the Foundation Session guid currently being used. Type: getter Source: Foundation.js, line 208 Example console.log(Foundation.guid) &lt;static&gt; name :setter Set the Foundation name. Set the Foundation name Type: setter Source: Foundation.js, line 256 Example Foundation.name = 'Provide the name here' &lt;static&gt; name :getter Get the Foundation name. Get the Foundation name Type: getter Source: Foundation.js, line 246 Example console.log(Foundation.name) &lt;static&gt; Schema :getter Creates new data schema. Creates new data schema Type: getter Source: Foundation.js, line 305 Example new Foundation.Schema({}) &lt;static&gt; started :getter Get the start state. Get the start state Type: getter Source: Foundation.js, line 267 Example console.log(Foundation.started) &lt;static&gt; tabId :getter Get the Browser tab ID. Get the Browser tab ID Type: getter Source: Foundation.js, line 236 Example console.log(foundation.tabId) &lt;static&gt; useWorker :getter flag if is there ServiceWorker being used. flag if is there ServiceWorker being used Type: getter Source: Foundation.js, line 431 Methods &lt;async, static&gt; registerApplicationWorker() Setup and Register the main Service worker used by foundation core. Setup and Register the main Service worker used by foundation core Source: Foundation.js, line 466 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Worker Registration Object Type object &lt;async, static&gt; registerWorker(name, workerFile) Setup and Register a Service worker and get it ready for usage into your application scope. Setup and Register a Service worker and get it ready for usage into your application scope Parameters: Name Type Description name string Worker name. Used to access it from the namespace workerFile string Worker file name Source: Foundation.js, line 502 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Worker Registration Object Type object &lt;static&gt; importDataEntity(spec) Alias to Foundation.mapToDataEntityAPI(entity = '', dataEntity = {}) An Data Entity abstraction is an instance of the DataEntity. Once it is mapped to foundation Data API, you can reach every Data Entity in the system from a single source point. This method dont works as expected if you call it after Foundation.start method Parameters: Name Type Description spec object Data Entity abstraction specification Properties Name Type Description entity string Data Entity name dataEntity dataEntity An DataEntity instance for the entity defined on `spec.entity` Source: Foundation.js, line 316 Example const productSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price: { type: Number, required: true, index: true } }) // start the foundation const foundation = new Foundation({ name: 'My Test app', schemas: { // Customer: schema } }) // Build a customized Data Entity abstraction const MyCustomizedDataEntity = class extends DataEntity { constructor (config) { super(config) } sell (primaryKey, orderId) { // primaryKey is Product primary key value // orderId is the primaryKey of an Order // const foundOrder = await Order.findById(orderId) // if (foundOrder.error) { // CAN NOT TO SELL // } // const items = foundOrder.data.lineItems.filter(i =&gt; (i.productId === primaryKey)) // If Order has the product listed item // if(items[0]) // { // await this.delete(primaryKey) // deletes a Product from Products // } } } // instance of the custimized Data Entity const productDataEntity = new MyCustomizedDataEntity({ foundation, entity: 'Product', schema: productSchema }) // import data entity foundation.importDataEntity({ entity: 'Product', dataEntity: productDataEntity }) // start the foundation await foundation.start() // you can now do things like: const { Product } = foundation.data await Product.add({ name: 'Big Mac', vendor: 'McDonalds', price: 3 }) &lt;static&gt; mapToDataEntityAPI(entity, dataEntity) Maps an Data Entity abstraction to foundation Data API An Data Entity abstraction is an instance of the DataEntity. Once it is mapped to foundation Data API, you can reach every Data Entity in the system from a single source point. This method dont works as expected if you call it after Foundation.start method. See Foundation.importDataEntity for usage further information. Parameters: Name Type Description entity string Data Entity name dataEntity dataEntity An DataEntity instance Source: Foundation.js, line 286 &lt;static&gt; setGuidStorage(guid) save Foundation uuid to localStorage. save Foundation uuid to localStorage Parameters: Name Type Description guid string Source: Foundation.js, line 440 Returns: Foundation uuid saved on localStorage &lt;static&gt; setupAppGuid() check if Foundation has a uuid saved o. check if Foundation has a uuid saved o Source: Foundation.js, line 451 Returns: Foundation uuid saved on localStorage &lt;async, static&gt; start() Starts foundation stack and get it ready to use. Starts foundation stack and get it ready to use. it calls this.#startVitals() internally Source: Foundation.js, line 575 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Foundation data Type object × Search results Close Sponsored by WEB2 Solutions "},"LocalDatabaseTransport.html":{"id":"LocalDatabaseTransport.html","title":"Class: LocalDatabaseTransport","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Class: LocalDatabaseTransport LocalDatabaseTransport new LocalDatabaseTransport(config) Database transport for IndexedDB. Database transport for IndexedDB Parameters: Name Type Description config object Transport configuration Properties Name Type Description version number Database version. Same as IndexedDB database version. tables object Database tables. Dexie tables configuration. dbName string Database name. Same as IndexedDB database name. Author: Eduardo Perotta de Almeida Source: LocalDatabaseTransport.js, line 9 See: The Data Transport is set into the Foundation stack and it is consumed inside DataEntity to persist data locally. LocalDatabaseTransport extends Dexie as database handler for IndexedDB. See Dexie Example import LocalDatabaseTransport from './LocalDatabaseTransport' import { Schema } from './utils' const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const ProductSchema = new Schema({ // ... }) const dbName = 'MyDatabaseName' const localDataTransport = new LocalDatabaseTransport({ version: 1, // default 1 tables: {}, // default {} dbName }) // or const localDataTransport = new LocalDatabaseTransport({ dbName }) localDataTransport.addSchema('User', UserSchema) localDataTransport.addSchema('Product', ProductSchema) await localDataTransport.connect() const Biden = await localDataTransport.table('User').add({ name: 'Joe Biden', username: 'biden'}) const Ferrari = await localDataTransport.table('Product').add({ name: 'Ferrari', vendor: 'Ferrari', price_cost: 3000000}) Extends dexie Methods &lt;static&gt; addSchema(schemaName, schema) A a Data Schema into the Schema tree. A a Data Schema into the Schema tree Parameters: Name Type Description schemaName string The schema name. Same as Entity name. schema object A valid mongoose like schema Source: LocalDatabaseTransport.js, line 91 Returns: schema - The schema enty from inside the Schema tree Type object Example const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) localDataTransport.addSchema('User', UserSchema) &lt;async, static&gt; connect() Setup connection to local database. Setup connection to local database Source: LocalDatabaseTransport.js, line 115 Returns: Foundation uuid saved on localStorage signature - Default methods signature format { error, data } Type object signature.error - Execution error information Type string | object signature.data - Connection information Type object Example await localDataTransport.connect() × Search results Close Sponsored by WEB2 Solutions "},"module-utils.html":{"id":"module-utils.html","title":"Module: utils","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Module: utils Author: Eduardo Perotta de Almeida Source: utils.js, line 6 Methods &lt;static&gt; createMethodSignature(error, data) createMethodSignature Create default signature method object. createMethodSignature Create default signature method object Parameters: Name Type Description error string | object The string or error object if have any data object | array | number | string | boolean Information about method execution Source: utils.js, line 21 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Execution data Type object | array | number | string | boolean &lt;static&gt; getSearchTokenStream() getSearchTokenStream generates a lunr search token. getSearchTokenStream generates a lunr search token. See lunr search Source: utils.js, line 97 Returns: token Type array &lt;static&gt; mongooseToDexieTableString() mongooseToDexieTableString convert given Mongoose schema to a Dexie Table columns configuration. mongooseToDexieTableString convert given Mongoose schema to a Dexie Table columns configuration. All columns inside returned configuration are indexed at IndexedDB prepend __id as local primary key and _id for remote primary key Local primary key is integer and auto incremented Source: utils.js, line 61 Returns: Dexie table configuration string Type string &lt;static&gt; toJSON(obj) toJSON - stringify and parse an object It uses native JSON internally. toJSON - stringify and parse an object It uses native JSON internally. Parameters: Name Type Description obj string | object Valid JSON object or string Source: utils.js, line 45 Returns: new JSON object Type object &lt;static&gt; uuid() uuid generates a Universally unique identifier string. uuid generates a Universally unique identifier string Source: utils.js, line 31 Returns: guid / uuid Type string × Search results Close Sponsored by WEB2 Solutions "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
