<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"DataEntity.js.html":{"id":"DataEntity.js.html","title":"Source: DataEntity.js","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Source: DataEntity.js /* global localStorage, navigator, window */ import EventSystem from './EventSystem' // import Dexie from 'dexie' import mongoose from 'mongoose' import { createMethodSignature, toJSON } from './utils' /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class DataEntity * @summary Data Entity API * @description When composing web applications using this library, we strongly believe the data design and plan should be the entry point of your software design. * &lt;br&gt;&lt;br&gt;The Entity Relationship diagram shall to be one of the initial documents you should to design before starting to write your software. * &lt;br&gt;&lt;br&gt;We assume the {@link https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model|Entity Relationship} and {@link https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model|Data Entity} models as technique and paradigm to design the application data. * &lt;br&gt;&lt;br&gt;If you have no idea of how agile you could to design your ER diagram, please take a look at some tools like {@Link https://www.datensen.com/data-modeling/moon-modeler-for-databases.html|Moon Modeler} * &lt;br&gt;&lt;br&gt; Every Data Entity in the system has it own encapsulated properties and methods that cares about where entity data is writen to and read from. * &lt;br&gt;&lt;br&gt; The DataEntity relies on the application instance (passed to it constructor) to access the available data transports. * &lt;br&gt;It means you can not use DataEntity prior starting a data transport layer. * &lt;br&gt;&lt;br&gt; This class is not for direct usage in your project, unless you are a core developer or want to understand what happens behind the scenes, you should consider to take a look at the {@link Foundation} class. * @extends EventSystem * @param {object} DataEntityConfig - Data Entity configuration * @param {string} DataEntityConfig.foundation - Provide Accesss to Foundation scope * @param {string} DataEntityConfig.entity - Data entity name which this dataEntity instance is handling * @param {boolean} DataEntityConfig.strategy - Data transport strategy * @param {boolean} DataEntityConfig.schema - Data schema for this Data Entity abstraction. &lt;br&gt; Do not declare the params __id and _id inside your schemas. * @example import { Schema } from '../foundation/Foundation' const schema = new Schema({ // do not declare __id // do not declare _id name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const Customer = new DataEntity({ foundation, // Foundation instance, object entity: 'Customer', // entity name, string strategy: 'offline', // data strategy, string schema // data schema, a mongoose like schema }) // listen to add Customer Data event on Data API const onAddDocEventListener = Customer.on( 'add', function(eventObj){ const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // listen to edit Customer Data event on Data API const onEditDocEventListener = Customer.on( 'edit', function (eventObj) { const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // listen to delete Customer Data event on Data API const onDeleteDocEventListener = Customer.on( 'delete', function (eventObj) { const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // Stop to listen to events to avoid memory leak or others kind of problems // like to change the state of an unmounted component. // Do something like this -&gt; before component unmount OR before window unload Customer.stopListenTo(onAddDocEventListener) Customer.stopListenTo(onEditDocEventListener) Customer.stopListenTo(onDeleteDocEventListener) */ export default class DataEntity extends EventSystem { #_foundation #_entity #_strategy #_schema #_pagination #_stateChangeStorageName constructor({ foundation, entity, strategy = 'offline', schema }) { super() /* if (Object.keys(foundation).length === 0) { throw new Error('foundation is invalid') } if (Object.keys(schema).length === 0) { throw new Error('schema is invalid') } if (entity === null) { throw new Error('entity is invalid') } */ this.#_entity = entity /** * @memberof DataEntity * @member {property} DataEntity.#_strategy * @summary PRIVATE - Holds the data transport strategy for this Data Entity. * @description * Default strategy is &lt;b&gt;offline&lt;/b&gt;. &lt;br&gt;&lt;br&gt; * Possible values are: &lt;br&gt; * - offlineFirst&lt;br&gt; * Data will be saved on local database first.&lt;br&gt; * - onlineFirst&lt;br&gt; * Data will be saved on remote database first.&lt;br&gt; * - offline&lt;br&gt; * Data will be saved on local database only.&lt;br&gt; * - online&lt;br&gt; * Data will be saved on remote database only.&lt;br&gt; */ this.#_strategy = strategy // offlineFirst, onlineFirst, offline, online /** * @memberof DataEntity * @member {property} DataEntity.#_schema * @summary PRIVATE - Holds the data schema for this Data Entity * @description Data schema is a mongoose.Schema implementation */ this.#_schema = schema this.#_foundation = foundation /** * @memberof DataEntity * @member {property} DataEntity.#_pagination * @summary PRIVATE - default internal paging configuration * @description The default paging configuration is: offset: 0, limit 30. It means it will returns 30 documents starting on index 0. */ this.#_pagination = { offset: 0, limit: 30 } this.#_stateChangeStorageName = `__$tabEntityStateChange_${this.#_entity}` this.#_foundation.localDatabaseTransport.addSchema(this.#_entity, this.#_schema) this.#_listenToAllOtherSessionsStateChanges() } /** * @memberof DataEntity * @member {getter} DataEntity.entity * @example // console.log(DataEntity.entity) * @description Gets the entity name which which DataEntity instance is handling out * @return {object} this.#_entity */ get entity () { return this.#_entity } /** * @memberof DataEntity * @member {getter} DataEntity.schema * @example // console.log(DataEntity.schema) * @description Gets the data schema related to this Entity Data API * @return {object} this.#_schema */ get schema () { return this.#_schema } /** * @memberof DataEntity * @member {getter} DataEntity.strategy * @example // console.log(DataEntity.strategy) * @description Gets the data strategy currently being used * @return {string} this.#_strategy */ get strategy () { return this.#_strategy } /** * @Method DataEntity.Model * @description create a Data Model based on given document * @param {object} doc - A valid document validated against mongoose schema * @param {object} schema - Mongoose based schema * @return {object} model - Mongoose document */ Model(doc, schema) { const modelSystem = mongoose.Document modelSystem.prototype.isNotValid = modelSystem.prototype.validateSync return modelSystem(doc, schema) } /** * @async * @Method DataEntity.add * @description add a new document to the storage * @param {object} doc - A valid document validated against mongoose schema * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Created document * @example const doc = { name: 'Eduardo Almeida', address: 'Av. Beira Mar. Praia do Morro, Guarapari - ES. Brazil.', email: 'web2solucoes@gmail.com', cards: [] } const { data, error } = await Customer.add(doc) */ async add(doc = {}) { // if (!(doc instanceof Document)) { // return createMethodSignature('You must pass a valid JSON document as parameter to DataEntity.add() method', null) // } if (Object.keys(doc).length &lt; 1) { return createMethodSignature('You must pass a valid JSON document as parameter to DataEntity.add() method', null) } let data = null let error = null let rawObj = {} // console.log('doc', doc) delete doc.__id delete doc._id const model = new this.Model(doc, this.#_schema) // console.log('model', model) const invalid = model.validateSync() if (invalid) { return createMethodSignature(invalid, data) } rawObj = toJSON(model) // console.log('add', rawObj) // bug if (typeof rawObj._id === 'undefined' &amp;&amp; typeof rawObj.id !== 'undefined') { rawObj._id = rawObj.id } try { const __id = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .add({ ...rawObj }) data = { __id, ...rawObj } // console.log('data', data) // console.log('__id', __id) } catch (e) { // console.log('error error ', e) error = e } // console.log({ data, error, rawObj }) this.#_triggerAddEvents({ data, error, primaryKey: (typeof data.__id === 'undefined' ? 0 : data.__id), rawObj }) return createMethodSignature(error, data) } /** * @Method DataEntity.#_triggerAddEvents * @description PRIVATE - Triggers all events related to 'add document' event * @param {object} eventPayload - Object containing all information about the event * @param {object} eventPayload.data - The new document inserted into database, default is null if not provided * @param {object|string} eventPayload.error - The returned error from database add request if any, default is null if not provided * @param {number} eventPayload.primaryKey - The primaryKey value of the added document, default is zero if not provided * @param {object} eventPayload.rawObj - The raw document object provided on dataEntity.add(doc) mehod call. Default is {} if not provided. */ #_triggerAddEvents({ data, error, primaryKey, rawObj}) { const action = 'add' this.#_foundation.triggerEvent(`collection:${action}:${this.#_entity.toLowerCase()}`, { foundation: this.#_foundation, entity: this.#_entity, document: rawObj, primaryKey, data, error, }) this.triggerEvent(action, { foundation: this.#_foundation, entity: this.#_entity, document: rawObj, primaryKey, data, error, }) const state = { action, data, error, document: rawObj, primaryKey } this.#_sendStateChangeToAllOtherSessions(state) } /** * @async * @Method DataEntity.edit * @description Edit a document on the storage * @param {string|number} primaryKey - The primary key value of the desired document * @param {object} doc - A valid document validated against mongoose schema * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Edited document * @example const doc = { __id: 1, _id: '601cb8d8623dc60000ee3c24', name: 'Eduardo Almeida', address: 'Av. Beira Mar. Praia do Morro, Guarapari - ES. Brazil.', email: 'web2solucoes@gmail.com', cards: [] } const { data, error } = await Customer.edit(doc.__id, doc) */ async edit(primaryKey = null, doc = {}) { // if (!(doc instanceof Document)) { // return createMethodSignature('You must pass a valid JSON document as parameter to DataEntity.edit() method', null) // } if (Object.keys(doc).length &lt; 1) { return createMethodSignature('You must pass a valid JSON document as parameter to DataEntity.edit() method', null) } if (primaryKey === null) { return createMethodSignature('You must pass a valid primary key value as parameter to DataEntity.edit() method', null) } if (typeof doc.__id !== 'number') { return createMethodSignature('Document must have doc.__id (Integer) when calling DataEntity.edit() method', null) } if (typeof doc._id !== 'string') { return createMethodSignature('Document must have doc._id (ObjectID) when calling DataEntity.edit() method', null) } primaryKey = +primaryKey let data = null let error = null let rawObj = {} try { const model = new this.Model(doc, this.#_schema) const invalid = model.validateSync() if (invalid) { return createMethodSignature(invalid, data) } rawObj = toJSON(model) rawObj.__id = primaryKey // bug const response = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .put({ ...rawObj }) // .update({ __id: primaryKey }, { ...rawObj }) data = { __id: primaryKey, ...rawObj } /* if (response.modifiedCount === 1) { data = { __id: primaryKey, ...rawObj } } else { data = null error = { message: 'Critical query error on update', response } } */ } catch (e) { error = e } this.#_triggerEditEvents({ data, error, primaryKey, rawObj }) return createMethodSignature(error, data) } /** * @Method DataEntity.#_triggerEditEvents * @description PRIVATE - Triggers all events related to 'edit document' event * @param {object} eventPayload - Object containing all information about the event * @param {object} eventPayload.data - The new document updated into database, default is null if not provided * @param {object|string} eventPayload.error - The returned error from database edit request if any, default is null if not provided * @param {number} eventPayload.primaryKey - The primaryKey value of the edited document, default is zero if not provided * @param {object} eventPayload.rawObj - The raw document object provided on dataEntity.edit(primaryKey, doc) mehod call. Default is {} if not provided. */ #_triggerEditEvents({ data, error, primaryKey, rawObj }) { const action = 'edit' this.#_foundation.triggerEvent( `collection:${action}:${this.#_entity.toLowerCase()}`, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, document: rawObj, data, error } ) this.triggerEvent( action, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, document: rawObj, data, error } ) const state = { action, data, error, document: rawObj, primaryKey } this.#_sendStateChangeToAllOtherSessions(state) } /** * @async * @Method DataEntity.delete * @description delete a document from the storage * @param {string|number} primaryKey - The primary key value of the desired document * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Deleted document */ async delete(primaryKey) { primaryKey = +primaryKey let data = null let error = null let rawObj = {} try { const __id = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .delete(primaryKey) // console.error({ __id }) data = { __id: primaryKey } } catch (e) { error = e } this.#_triggerDeleteEvents({ data, error, primaryKey }) return createMethodSignature(error, data) } /** * @Method DataEntity.#_triggerDeleteEvents * @description PRIVATE - Triggers all events related to 'delete document' event * @param {object} eventPayload - Object containing all information about the event * @param {object} eventPayload.data - A object containing the __id property of the deleted document, default is null if not provided * @param {object|string} eventPayload.error - The returned error from database edit request if any, default is null if not provided * @param {number} eventPayload.primaryKey - The primaryKey value of the deleted document, default is zero if not provided */ #_triggerDeleteEvents({ data, error, primaryKey }) { const action = 'delete' this.#_foundation.triggerEvent( `collection:${action}:${this.#_entity.toLowerCase()}`, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, data, error } ) this.triggerEvent( action, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, data, error } ) const state = { action, data, error, primaryKey } this.#_sendStateChangeToAllOtherSessions(state) } /** * @async * @Method DataEntity.findById * @description find a document from the storage by ID * @param {string|number} primaryKey - The primary key value of the desired document * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Found document */ async findById (primaryKey) { let data = null let error = null try { primaryKey = parseInt(primaryKey) const doc = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .get(primaryKey) // console.log({ __id: primaryKey, doc }) if (doc) { if (doc.__id === primaryKey) { data = { __id: primaryKey, ...doc } } } } catch (e) { error = e } return createMethodSignature(error, data) } /** * @async * @Method DataEntity.findAll * @summary Find all documents * @description This method will to return all documents based on the given query. If no query is specified, it will returns all records from this collection * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {array} signature.data - Array of Found documents */ async findAll(query = {}) { let data = null let error = null try { const documents = await this.#_foundation .localDatabaseTransport .collection(this.#_entity) .find(query) .toArray() data = documents } catch (e) { error = e } return createMethodSignature(error, data) } /** * @async * @Method DataEntity.find * @summary find documents based on the given query and returns a paginated response * @description This method will to return the documents based on the given query and the specified paging. If no query is specified, it will returns documents based on paging only. * @param {object|null} query - The query object to search documents * @param {object} pagination - Pagination object. If not provided will assume internaly set pagination. * @param {number} pagination.offset - Offset. Default 0. * @param {number} pagination.limit - Limit. Default 30. * @example User.find({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {array} signature.data - Array of Found documents */ async find(query = {}, pagination = this.#_pagination) { let { offset, limit } = pagination let data = null let error = null try { const documents = await this.#_foundation .localDatabaseTransport .collection(this.#_entity) .find(query) .reverse() .offset(offset) .limit(limit) .toArray() data = documents } catch (e) { error = e } return createMethodSignature(error, data) } /** * @async * @Method DataEntity.count * @description count all documents based on the given query * @param {object} query - The query object to count documents * @example User.count({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {number} signature.data - Documents counter */ async count (query = {}) { let data = null let error = null try { const counter = await this.#_foundation .localDatabaseTransport .collection(this.#_entity) .count(query) data = counter } catch (e) { error = e } return createMethodSignature(error, data) } /** * @Method DataEntity.#_listenToAllOtherSessionsStateChanges * @summary PRIVATE - Listen to data state changes on every Application session. * @description Listen to data state change event incoming from every other Application session and communicates to every subscriber tied to this session. * &lt;br&gt;&lt;br&gt; The application scope is the browser running the application. * &lt;br&gt;&lt;br&gt; Every tab is considered a session. * &lt;br&gt; &lt;br&gt; Internally it triggers all events related to data change events, except if the source, the session which originated the event, is the same that is receiving the event * &lt;br&gt; &lt;br&gt; It does not rely on network to propagate the changes. * @example this.#_listenToAllOtherSessionsStateChanges() */ #_listenToAllOtherSessionsStateChanges() { window.addEventListener('storage', (event) =&gt; { if (event.key === this.#_stateChangeStorageName) { const { key, newValue, oldValue } = event if (newValue) { // console.log('DATAAPI -&gt; got new state change', { key, newValue, oldValue }) const jsonState = JSON.parse(newValue) const { error, data, entity, action, source, document } = jsonState // console.error({ error, data, entity, action, source, document }) const eventObj = { foundation: this.#_foundation, entity: entity, document: document, data, error } this.#_foundation.triggerEvent(`collection:${action}:${entity.toLowerCase()}`, eventObj) this.triggerEvent(action, eventObj) } // oldValue } }) } /** * @Method DataEntity.#_sendStateChangeToAllOtherSessions * @summary PRIVATE - Sends data state changes information to every other current application session. * @description The application scope is the browser running the application. &lt;br&gt; Every tab is considered a session.&lt;br&gt; It can not rely on network. * @param {object} state - Object containing all information about the state * @param {object} state.data - The modified data, default is null if not provided * @param {object|string} state.error - The returned error when trying to modify the data, default is null if not provided * @param {object} state.document - The raw object used as value to get the new data state, default is {} if not provided * @example this.#_sendStateChangeToAllOtherSessions({ action: 'add', data: {...newDocument}, error: null, document: {...originalDocument} }) */ #_sendStateChangeToAllOtherSessions(state) { // state { action: '', data: null, error: null, document: {} } state.source = { sessionId: this.#_foundation.tabId, applicationId: this.#_foundation.guid, } state.entity = this.#_entity const stateChange = JSON.stringify(state) window.localStorage.setItem(this.#_stateChangeStorageName, stateChange) window.localStorage.removeItem(this.#_stateChangeStorageName) } } × Search results Close Sponsored by WEB2 Solutions "},"Foundation.js.html":{"id":"Foundation.js.html","title":"Source: Foundation.js","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Source: Foundation.js /* global localStorage, navigator, window */ import { createMethodSignature, uuid, Schema, genDbName } from './utils' import DataEntity from './DataEntity' import LocalDatabaseTransport from './LocalDatabaseTransport' import EventSystem from './EventSystem' // import workerOnMessage from './events/workerOnMessage' /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class Foundation * @description Foundation boostrap class * @extends EventSystem * @param {object} config - Foundation configuration * @param {string} config.name - Foundation name * @param {string} config.dataStrategy - Data strategy. Recognized values: offlineFirst, onlineFirst, offline, online * @param {boolean} config.useWorker - Use a ServiceWorker in Background * @param {object} config.schemas - map of data schemas * @example {@lang javascript} // =========&gt; main.js // import React import React from 'react' import ReactDOM from 'react-dom' // import Bootstrap import 'bootstrap/dist/css/bootstrap.css' // import React app import App from './App' // import agnostic foundation foundation class import Foundation from './foundation/Foundation' const CustomerSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const OrderSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, shipTo: { type: String, required: true, index: true }, paymentMethod: { type: String, required: true, index: true }, amount: { type: Number, required: true, default: 0, index: true }, date: { type: Date, default: Date.now, index: true } }) const ProductSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new Foundation.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Foundation({ name: 'My App', useWorker: true, dataStrategy: 'offline', schemas: { User: UserSchema, Product: ProductSchema, Order: OrderSchema, Customer: CustomerSchema } }) foundation.on('foundation:start', async function(eventObj) { const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start foundation and get it ready to be used await foundation.start() const start = await foundation.start() if (start.error) { throw new Error(`Error starting foundation stack: ${start.error}`) } // console.debug('start', start) ReactDOM.render( &lt;App foundation={foundation} /&gt;, document.getElementById('root') ) */ export default class Foundation extends EventSystem { #_schemas #_name #_dataStrategy #_started #_models #_guid #_useWorker #_workers #_tabId constructor ({ name = 'My Foundation Name', dataStrategy = 'offline', useWorker = false, schemas }) { super() this.#_name = name this.#_dataStrategy = dataStrategy this.#_useWorker = useWorker this.#_schemas = schemas this.#_started = false this.#_guid = uuid() this.#_models = {} this.#_useWorker = useWorker || false this.#_workers = {} this.localDatabaseTransport = new LocalDatabaseTransport({ dbName: genDbName(name) }) this.#_tabId = uuid() // assume new Id on every refresh } /** * @member {getter} Foundation.dataStrategy * @Description Get the data strategy being used.&lt;br&gt; Possible values are: offlineFirst, onlineFirst, offline, online. &lt;br&gt; Default: offlineFirst * @example console.log(Foundation.dataStrategy) * @return {string} this.#_dataStrategy */ get dataStrategy () { return this.#_dataStrategy } /** * @member {getter} Foundation.guid * @description Get the Foundation Session guid currently being used. * @example console.log(Foundation.guid) */ get guid () { return this.#_guid } /** * @member {getter} Foundation.data * @description Get the Foundation data API(DataEntity) * @example const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug(Eduardo) // { // data: {__id: 1, _id: \"600e0ae8d9d7f50000e1444b\", name: \"Eduardo Almeida\", username: \"web2\", id: \"600e0ae8d9d7f50000e1444b\"} // error: null // } */ get data() { return this.#_models } /** * @member {getter} Foundation.tabId * @description Get the Browser tab ID * @example console.log(foundation.tabId) */ get tabId() { return this.#_tabId } /** * @member {getter} Foundation.name * @name Foundation.name * @description Get the Foundation name * @example console.log(Foundation.name) */ get name () { return this.#_name } /** * @member {setter} Foundation.name * @name Foundation.name * @description Set the Foundation name * @example Foundation.name = 'Provide the name here' * @param {string} name - Foundation name */ set name (name) { this.#_name = name } /** * @member {getter} Foundation.started * @description Get the start state * @example console.log(Foundation.started) */ get started () { return this.#_started } /** * @memberof Foundation * @member {getter} Foundation.applicationWorker * @example Foundation.applicationWorker.postMessage() * @description Get the Foundation worker */ get applicationWorker() { return this.#_workers.foundation } /** * @Method Foundation.mapToDataEntityAPI * @summary Maps an Data Entity abstraction to foundation Data API * @description An Data Entity abstraction is an instance of the {@link DataEntity}. * Once it is mapped to foundation Data API, you can reach every Data Entity in the system from a single source point. * This method dont works as expected if you call it after {@link Foundation.start} method. * See {@link Foundation.importDataEntity} for usage further information. * @param {string} entity - Data Entity name * @param {dataEntity} dataEntity - An {@link DataEntity} instance */ mapToDataEntityAPI(entity, dataEntity) { let _error = null let _data = null // if call mapToDataEntityAPI('Product') more than once, it will ovewrite the previous set Product model this.#_models[entity] = dataEntity _data = this.#_models[entity] return createMethodSignature(_error, _data) } /** * @memberof Foundation * @member {getter} Foundation.Schema * @example new Foundation.Schema({}) * @description Creates new data schema * @returns schema creator */ static get Schema() { return Schema } /** * @Method Foundation.importDataEntity * @summary Alias to Foundation.mapToDataEntityAPI(entity = '', dataEntity = {}) * @description An Data Entity abstraction is an instance of the {@link DataEntity}. * Once it is mapped to foundation Data API, you can reach every Data Entity in the system from a single source point. * This method dont works as expected if you call it after {@link Foundation.start} method * @param {object} spec - Data Entity abstraction specification * @param {string} spec.entity - Data Entity name * @param {dataEntity} spec.dataEntity - An {@link DataEntity} instance for the entity defined on `spec.entity` * @example const productSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price: { type: Number, required: true, index: true } }) // start the foundation const foundation = new Foundation({ name: 'My Test app', schemas: { // Customer: schema } }) // Build a customized Data Entity abstraction const MyCustomizedDataEntity = class extends DataEntity { constructor (config) { super(config) } sell (primaryKey, orderId) { // primaryKey is Product primary key value // orderId is the primaryKey of an Order // const foundOrder = await Order.findById(orderId) // if (foundOrder.error) { // CAN NOT TO SELL // } // const items = foundOrder.data.lineItems.filter(i =&gt; (i.productId === primaryKey)) // If Order has the product listed item // if(items[0]) // { // await this.delete(primaryKey) // deletes a Product from Products // } } } // instance of the custimized Data Entity const productDataEntity = new MyCustomizedDataEntity({ foundation, entity: 'Product', schema: productSchema }) // import data entity foundation.importDataEntity({ entity: 'Product', dataEntity: productDataEntity }) // start the foundation await foundation.start() // you can now do things like: const { Product } = foundation.data await Product.add({ name: 'Big Mac', vendor: 'McDonalds', price: 3 }) */ importDataEntity({ entity, dataEntity}) { this.mapToDataEntityAPI(entity, dataEntity) } #mapModels(schemas) { let _error = null let _data = null for (const entity in schemas) { if (Object.prototype.hasOwnProperty.call(schemas, entity)) { // console.debug('for (const entity in schemas)', entity) const strategy = 'offlineFirst' const schema = schemas[entity] const dataEntity = new DataEntity({ foundation: this, entity, strategy, schema }) this.mapToDataEntityAPI(entity, dataEntity) } } // _data = this.#_models // return createMethodSignature(_error, _data) } /** * @member {getter} Foundation.useWorker * @Description flag if is there ServiceWorker being used * @return {boolean} */ get useWorker () { return this.#_useWorker } /** * @Method Foundation.setGuidStorage * @description save Foundation uuid to localStorage * @param {string} guid * @return Foundation uuid saved on localStorage */ setGuidStorage (guid) { window.localStorage.setItem('guid', guid) return window.localStorage.getItem('guid') } /** * @Method Foundation.setupAppGuid * @description check if Foundation has a uuid saved o * @return Foundation uuid saved on localStorage */ setupAppGuid () { const guidCache = window.localStorage.getItem('guid') || false if (guidCache) { this.#_guid = guidCache } else { this.setGuidStorage(this.#_guid) } return window.localStorage.getItem('guid') } /** * @async * @Method Foundation.#registerApplicationWorker * @description Setup and Register the main Service worker used by foundation core * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Worker Registration Object */ /* #registerApplicationWorker (workerFile = 'ServiceWorker.js') { const self = this return new Promise((resolve, reject) =&gt; { if ('serviceWorker' in navigator) { navigator.serviceWorker .register('/' + workerFile, { // scope: '/' }) .then(function (reg) { // registration worked navigator.serviceWorker.addEventListener('message', workerOnMessage.bind(self)) if (reg.installing) { self.#_workers['foundation'] = reg.installing self.#_workers['foundation'].postMessage({ cmd: 'getClientId', message: null }) } else if (reg.active) { self.#_workers['foundation'] = reg.active self.#_workers['foundation'].postMessage({ cmd: 'getClientId', message: null }) } resolve(createMethodSignature(null, reg)) }) .catch(function (error) { // registration failed resolve(createMethodSignature(error, null)) }) } }) } */ /** * @async * @Method Foundation.#registerWorker * @description Setup and Register a Service worker and get it ready for usage into your application scope * @param {string} name - Worker name. Used to access it from the namespace * @param {string} workerFile - Worker file name * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Worker Registration Object */ /* #registerWorker (name = '', workerFile = 'ServiceWorker.js') { const self = this return new Promise((resolve, reject) =&gt; { if ('serviceWorker' in navigator) { navigator.serviceWorker .register('/' + workerFile, { // scope: '/' }) .then(function (reg) { // registration worked navigator.serviceWorker.addEventListener('message', workerOnMessage.bind(self)) if (reg.installing) { self.#_workers[name] = reg.installing self.#_workers[name].postMessage({ cmd: 'getClientId', message: null }) } else if (reg.active) { self.#_workers[name] = reg.active self.#_workers[name].postMessage({ cmd: 'getClientId', message: null }) } resolve(createMethodSignature(null, reg)) }) .catch(function (error) { // registration failed resolve(createMethodSignature(error, null)) }) } }) } */ /** * @async * @Method Foundation.start * @description Starts foundation stack and get it ready to use. &lt;br&gt; it calls this.#startVitals() internally * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Foundation data */ async start () { let _error = null let _data = null try { this.setupAppGuid() const mapModels = this.#mapModels(this.#_schemas) const connection = await this.localDatabaseTransport.connect() if (connection.error) { _error = connection.error } else { this.#_started = true _data = { status: { mapModels, connection }, started: this.#_started } } } catch (error) { _error = error _data = null } this.triggerEvent('foundation:start', { foundation: this, error: _error, data: _data }) // console.warn('STARTED&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;', this) return createMethodSignature(_error, _data) } } × Search results Close Sponsored by WEB2 Solutions "},"LocalDatabaseTransport.js.html":{"id":"LocalDatabaseTransport.js.html","title":"Source: LocalDatabaseTransport.js","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Source: LocalDatabaseTransport.js import dexie from 'dexie' import 'dexie-mongoify' import { createMethodSignature, mongooseToDexieTableString } from './utils' dexie.debug = false /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class LocalDatabaseTransport * @description Database transport for IndexedDB * @extends dexie * @see The Data Transport is set into the {@link Foundation} stack and it is consumed inside {@link DataEntity} to persist data locally. * @see {@link LocalDatabaseTransport} extends {@link https://dexie.org/docs/Dexie/Dexie|Dexie} as database handler for IndexedDB. See {@link https://dexie.org/docs/Dexie/Dexie|Dexie} * @param {object} config - Transport configuration * @param {number} config.version - Database version. &lt;br&gt;Same as IndexedDB database version. * @param {object} config.tables - Database tables. &lt;br&gt;Dexie tables configuration. * @param {string} config.dbName - Database name. &lt;br&gt;Same as IndexedDB database name. * @example {@lang javascript} import LocalDatabaseTransport from './LocalDatabaseTransport' import { Schema } from './utils' const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const ProductSchema = new Schema({ // ... }) const dbName = 'MyDatabaseName' const localDataTransport = new LocalDatabaseTransport({ version: 1, // default 1 tables: {}, // default {} dbName }) // or const localDataTransport = new LocalDatabaseTransport({ dbName }) localDataTransport.addSchema('User', UserSchema) localDataTransport.addSchema('Product', ProductSchema) await localDataTransport.connect() const Biden = await localDataTransport.table('User').add({ name: 'Joe Biden', username: 'biden'}) const Ferrari = await localDataTransport.table('Product').add({ name: 'Ferrari', vendor: 'Ferrari', price_cost: 3000000}) */ export default class LocalDatabaseTransport extends dexie { #_version #_tables #_connected #_schemas #_dbName constructor ({ version = 1, tables = {}, dbName }) { // console.error('STARTED LocalDatabaseTransport') // run the super constructor Dexie(databaseName) to create the IndexedDB // database. super(dbName) this.#_dbName = dbName this.#_version = version this.#_tables = tables this.#_connected = false this.#_schemas = {} } #_setTables() { for (const entity in this.#_schemas) { if (Object.prototype.hasOwnProperty.call(this.#_schemas, entity)) { // console.error(entity) this.#_tables[entity] = mongooseToDexieTableString( this.#_schemas[entity] ) } } } /** * @Method LocalDatabaseTransport.addSchema * @description A a Data Schema into the Schema tree * @param {string} schemaName - The schema name. Same as Entity name. * @param {object} schema - A valid mongoose like schema * @example const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) localDataTransport.addSchema('User', UserSchema) * @return {object} schema - The schema enty from inside the Schema tree */ addSchema (schemaName, schema) { this.#_schemas[schemaName] = schema return this.#_schemas[schemaName] } /** * @async * @Method LocalDatabaseTransport.connect * @description Setup connection to local database * @return Foundation uuid saved on localStorage * @example await localDataTransport.connect() * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error information * @return {object} signature.data - Connection information */ async connect() { let error = null let data = null try { this.#_setTables() this .version(this.#_version) .stores(this.#_tables) // for (const tableName in this.#_tables) { // this[tableName] = this.table(tableName) // } const open = await this.open() data = open } catch (e) { error = e data = null } return createMethodSignature(error, data) } } × Search results Close Sponsored by WEB2 Solutions "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Source: utils.js /* global lunr */ import lunr from 'lunr' import mongoose from 'mongoose' // const lunr = require('lunr') // console.debug('&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;', lunr) /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @module utils * */ /** * createMethodSignature * Create default signature method object * @function * @param {string|object} error - The string or error object if have any * @param {object|array|number|string|boolean} data - Information about method execution * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object|array|number|string|boolean} signature.data - Execution data */ export const createMethodSignature = (error = null, data = null) =&gt; { const response = { error, data } return response } /** * uuid * generates a Universally unique identifier string * @function * @return {string} guid / uuid */ export function uuid () { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { const r = (Math.random() * 16) | 0 const v = c === 'x' ? r : (r &amp; 0x3) | 0x8 return v.toString(16) }) } /** * genDbName * generates a database name * @function * @param {string} appName - Voodux Application Instance name * @return {string} dbName / uuid */ export function genDbName(appName = '') { appName = appName.toLowerCase().replace(/ /g, '_') const dbName = `VooduX_${appName}` return dbName } /** * toJSON - stringify and parse an object&lt;br&gt; It uses native JSON internally. * @function * @param {string|object} obj - Valid JSON object or string * @return {object} new JSON object */ export function toJSON (obj = '') { if (typeof obj === 'string') { return JSON.parse(obj) } return JSON.parse(JSON.stringify(obj)) } /** * mongooseToDexieTableString * convert given Mongoose schema to a Dexie Table columns configuration. &lt;br&gt; * All columns inside returned configuration are indexed at IndexedDB * prepend __id as local primary key and _id for remote primary key * Local primary key is integer and auto incremented * @function * @return {string} Dexie table configuration string */ export function mongooseToDexieTableString(schema) { // console.log('XXXXXXX mongooseToDexieTableString') const cols = [] const notIndexed = [] for (let propertyName in schema.paths) { if (Object.prototype.hasOwnProperty.call(schema.paths, propertyName)) { const property = schema.paths[propertyName] // instance is type // _index can be boolean or object {unique: true} // options { default, index, required, unique } const { instance, _index, options: { unique = false }, /* isRequired */ } = property if (propertyName === '_id' || propertyName === '__id') { continue } if (!_index) { notIndexed.push(propertyName) continue } if (instance === 'Array') { propertyName = `*${propertyName}`// * is MultiEntry Index on Dexie } if (unique) { propertyName = `&amp;${propertyName}` // &amp; is unique Index on Dexie } cols.push(propertyName) } // end if has property }// end for const compoundIndexes = getCompoundIndexes(notIndexed, schema) if (compoundIndexes.length &gt; 0) { // console.log(`++__id,_id,${compoundIndexes.join(',')}${cols.length &gt; 0 ? (',' + cols.join(',')) : ''}`) return `++__id,_id,${compoundIndexes.join(',')}${cols.length &gt; 0 ? (',' + cols.join(',')) : ''}` } else { // console.log(`++__id,_id${cols.length &gt; 0 ? ',' + cols.join(',') : ''}`) return `++__id,_id${cols.length &gt; 0 ? ',' + cols.join(',') : ''}` } } /** * getCompoundIndexes * @summary PRIVATE getCompoundIndexes() - get compound indexes in a schema * @description * Compound keys are NOT initially indexed on schema property level,&lt;br&gt; * then we need to iterate over schema._index[0], which is the arrray containing all indexes including the compounds * @function * @param {array} notIndexed - name of not indexes columns/properties. * @param {object} schema - data schema object instance * @return {array} compoundIndexes */ function getCompoundIndexes(notIndexed, schema) { let compoundIndexes = [] const compoundKeys = [] // console.error('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; schema._indexes.length', schema._indexes.length) if (schema._indexes.length === 0) { return compoundIndexes } for (let x = 0; x &lt; notIndexed.length; x++) { const propertyName = notIndexed[x] // check if this property is listed on compoundKeys if (compoundKeys.indexOf(propertyName) &gt; -1) { continue } // console.error('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;', schema._indexes) const __indexes = schema._indexes[0] // get array of indexes for (let y = 0; y &lt; __indexes.length; y++) { const _index = __indexes[y] const keys = Object.keys(_index) // if property is a key of current _index then it is compound if (keys.indexOf(propertyName) &gt; -1) { compoundIndexes.push(`[${keys[0]}+${keys[1]}]`) keys.forEach(k =&gt; (compoundKeys.push(k))) // we already built the compound index, // there is no need to continue to iterate over __indexes break } } // remove keys from notIndexed array if it is component } return compoundIndexes } /** * getSearchTokenStream * generates a lunr search token. See {@link https://lunrjs.com/guides/searching.html|lunr search} * @function * @return {array} token */ export function getSearchTokenStream(text = '') { // console.log('xxxxxxxxx') // console.log('xxxxxxxxx', index) // const index = lunr() // return index.pipeline.run(lunr.tokenizer(text)) const token = (lunr.tokenizer(text)).map(t =&gt; (t.str)) return token // return lunr.tokenizer(text) } export const Schema = mongoose.Schema × Search results Close Sponsored by WEB2 Solutions "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Modules Classes DataEntity Data Entity API Foundation Foundation boostrap class. LocalDatabaseTransport Database transport for IndexedDB. × Search results Close Sponsored by WEB2 Solutions "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Classes Classes DataEntity Data Entity API Foundation Foundation boostrap class. LocalDatabaseTransport Database transport for IndexedDB. × Search results Close Sponsored by WEB2 Solutions "},"index.html":{"id":"index.html","title":"Index","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport main branch release branch develop branch VooduX Web application state on steroids. Summary VooduX is a proposal to cover some common lacks in modern web applications development. It heavly opinionate on how to define a strong underlying architecture which relies mostly in V-* like libraries and frameworks such as Vue and React. One common sense in every engineering field is: There is no single silver bullets for all existing problems. There is a giant race over React and Vue. They are likely the V in on a MVC like acronym. And in terms of Project Standards, that is all they care about. They usualy try to solve application data issues, but their proposed solutions are mostly focused in the application state rather than the application data. They mainly rely on browser memory to keep chunks of data. There is no problem on those solutions, not at least in a project standard perspective, because they ain't necessarily try to solve M related problems . By mistake, developers and teams are mostly focusing on the V layer and ignoring a possibly required underlying foundation architecture. Which finally increases the code complexity of those View or Component layers, because they are trying to resolve problems that should not being handled in that domain. State Management libraries are really great. But they don't scales. Simply because the application data size might considerable grows. An Application State Management abstraction handles pieces of data that are curenlty being used in the screen at the present moment. But it does not means you could not have another pieces of data being stored or handled in parallel, behind the scenes. Not least, quick data persistence is not enough. You may need to save your data to different locations, or sync multiple client applications, or even t handle a big amount of data on application startup. This where VooduX comes in. Let's make a simple comparison to quickly visualize the main difference between traditional React/Vue applications and a VooduX powered application: This is how a common React/Vue application looks like: This is how a VooduX powered React/Vue application looks like: Interactive code example Now let's see an interactive example: See the Pen VooduX - VanillaJS playground by Eduardo Almeida (@web2solutions) on CodePen. Install Via npm - Simple usage $ npm install voodux --save Via git - Advanced usage $ git clone https://github.com/web2solutions/voodux.git $ cd voodux $ npm install How to use This the Step by Step guide to use VooduX Importing VooduX into your application The first step to use VooduX in your project it to import it library. Require const voodux = require('voodux') const { Foundation, // LocalDatabaseTransport, // DataEntity, // utils } = voodux ES6 import In order to import the main library to your project just simply import it: import voodux from 'voodux' const { Foundation, // LocalDatabaseTransport, // DataEntity, // utils } = voodux Browser directly usage &lt;script type=\"text/javascript\" src=\"voodux/dist/main.min.js\"&gt;&lt;/script&gt; React and Vue Project Structure This is how a hypotethical React or Vue project structure looks like. This example is assuming the fact that your application have 4 pages: Dashboard Customers Orders Products ├── dist -&gt; Final app code goes here ├── docs │ ├── code -&gt; JSDoc documentation will be saved here │ └── reports -&gt; Karma reports will be saved here ├── html_app -&gt; Original static files ├── test -&gt; Test suites goes here ├── src │ ├── components │ │ ├── customers │ │ │ ├── CustomersAdd.js -&gt; Add form │ │ │ ├── CustomersEdit.js -&gt; Edit form │ │ │ ├── index.js -&gt; Main listing page │ │ │ └── events -&gt; Event Handlers decoupled from component files │ │ ├── dashboard │ │ │ ├── Chart.js -&gt; Finance Chart │ │ │ ├── index.js -&gt; Main listing page │ │ │ └── events -&gt; Event Handlers decoupled from component files │ │ ├── orders │ │ │ ├── OrdersAdd.js -&gt; Add form │ │ │ ├── index.js -&gt; Main listing page │ │ │ └── events -&gt; Event Handlers decoupled from component files │ │ ├── products │ │ │ ├── ProductsAdd.js -&gt; Add form │ │ │ ├── ProductsEdit.js -&gt; Edit form │ │ │ ├── index.js -&gt; Main listing page │ │ │ └── events -&gt; Event Handlers decoupled from component files │ ├── events -&gt; Decoupled Application Event handlers │ ├── schemas -&gt; Data Entity Schemas (or Data Models) are saved here │ ├── App.css │ ├── App.js -&gt; React/Vue Application code │ └── main.js -&gt; Application entry point ├── test ├── .babelrc -&gt; Babel configuration ├── .eslintignore -&gt; eslint ignore rules ├── .eslintrc.json -&gt; eslint configuration ├── .prettierrc -&gt; prettier configuration ├── jsDoc.json -&gt; JSDoc configuration ├── package.json └── webpack.config.js -&gt; webpack configuration Writing your application code The underlying architecture of every VooduX application borns in it Data Design. The VooduX strongly believes that the Data plan and Data design is the first step to take when building successful projects. That is why we start by defining some Data Schemas for the Data entities we have in the system. Every Data entity in the system has it own encapsulated methods to access, handle and notify data changes to every actor listening to it. Schemas must be provided in the foundation constructor or at least pior calling the foundation.start() method. Otherwise it collection will not be created inside the local database. Setup a data schema for a Data Entity Every Data Schema in a VooduX application is set using the Foundation.Schema(schema) static method. The data schemas are set following the Mongoose standard to define schemas. It means you are not repeating yourself when writing data schemas because they targets both the front end and back end. In other words, server and client data are being defined by a single contract. import voodux from 'voodux' const { Foundation, LocalDatabaseTransport, DataEntity, utils } = voodux const CustomerSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) Foundation constructor The starting point of every voodux application is it Foundation. The application foundation holds things like data definition, data access, data validation, data persistence, data change notification .... Prior starting your React or Vue application code, you must create your application foundation and then to pass it as property to your React or Vue application. The application foundation is set by calling the Foundation constructor. const foundation = new Foundation({ name: 'My App', schemas: { User: UserSchema, Product: ProductSchema, Order: OrderSchema, Customer: CustomerSchema } }) Listening to Application Start event Sometimes you may need to start executing heavy tasks prior start rendering your application screens. For example you could start a data sync process, starting to fill out you local database and in meantime, render a dashboard and start rendering data changes in realtime, as long as they are emitted from the Data Entity abstraction implementation. The foundation:start event listener must be set before calling foundation.start(). Otherwise it will not be triggered. foundation.on('foundation:start', async function(eventObj) { const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) Hypothetical full React app setup demo // import React lib import React from 'react' // import voodux import voodux from 'voodux' const { Foundation, LocalDatabaseTransport, DataEntity, utils } = voodux // setup Data schemas const CustomerSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const OrderSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, shipTo: { type: String, required: true, index: true }, paymentMethod: { type: String, required: true, index: true }, amount: { type: Number, required: true, default: 0, index: true }, date: { type: Date, default: Date.now, index: true } }) const ProductSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new Foundation.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Foundation({ name: 'My App', useWorker: true, dataStrategy: 'offlineFirst', schemas: { User: UserSchema, Product: ProductSchema, Order: OrderSchema, Customer: CustomerSchema } }) // listen to application start event and add some records to database. foundation.on('foundation:start', async function(eventObj) { const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start application foundation and get it ready to be used const start = await foundation.start() if (start.error) { throw new Error(`Error starting foundation stack: ${start.error}`) } // start rendering yout React application by passing the application foundation as it prop. ReactDOM.render( &lt;App foundation={foundation} /&gt;, document.getElementById('root') ) Hypothetical React Customers Listing component This component does render a list of Customers. On the list, every listed customer has associated delete and update links. The component has an array of customers as main state property. Ok, there is nothing new here! The dirty magic begins when the requirement list starting asking for things like: To be able to show the same data in the screen after browser refreshing and do not call the server API asking for those specific piece of data. Have a reliable and high performance 2-way dataflow model between Application Data Storage and Application State Manager. // pages/orders.js import React, { useState, useEffect, useContext } from 'react' import { Link, useHistory } from 'react-router-dom' import Grid from '@material-ui/core/Grid' import Paper from '@material-ui/core/Paper' import Table from '@material-ui/core/Table' import TableBody from '@material-ui/core/TableBody' import TableCell from '@material-ui/core/TableCell' import TableHead from '@material-ui/core/TableHead' import TableRow from '@material-ui/core/TableRow' // import Link from '@material-ui/core/Link' import Button from '@material-ui/core/Button' import ButtonGroup from '@material-ui/core/ButtonGroup' import useStyles from './useStyles' import swal from 'sweetalert' import FoundationContext from '../FoundationContext' import Title from './Title' // import custom hooks import onAddDocHook from './hooks/onAddDocHook' import onEditDocHook from './hooks/onEditDocHook' import onDeleteDocHook from './hooks/onDeleteDocHook' export default function Customers () { const [customers, setCustomers] = useState([]) const foundation = useContext(FoundationContext) const { Customer } = foundation.data const [newDoc] = onAddDocHook(Customer) const [editedDoc] = onEditDocHook(Customer) const [deletedDoc] = onDeleteDocHook(Customer) const history = useHistory() const classes = useStyles() const handleAddCustomer = (e) =&gt; { e.preventDefault() history.push('/CustomersAdd') } const handleDeleteCustomer = async (e, ___id) =&gt; { e.preventDefault() // console.error(___id) swal({ title: 'Are you sure?', text: 'Once deleted, you will not be able to recover this!', icon: 'warning', buttons: true, dangerMode: true }).then(async (willDelete) =&gt; { if (willDelete) { const r = await Customer.delete(___id) // console.error(r) if (r.error) { swal('Database error', e.error.message, 'error') return } swal('Poof! The customer has been deleted!', { icon: 'success' }) } else { swal('The Customer is safe!') } }) } // whatch for new docs useEffect(() =&gt; { if (newDoc !== null) { console.log('newDoc mudou', newDoc) setCustomers([newDoc, ...customers]) console.log('customers', customers) } }, [newDoc]) // watch for edited docs useEffect(() =&gt; { if (editedDoc !== null) { console.log('editedDoc mudou', editedDoc) const newData = customers.map((customer) =&gt; { if (customer.__id === editedDoc.__id) { return editedDoc } else { return customer } }) setCustomers([...newData]) console.log('customers', customers) } }, [editedDoc]) // watch for deleted docs useEffect(() =&gt; { if (deletedDoc !== null) { const allCustomers = [...customers] for (let x = 0; x &lt; allCustomers.length; x++) { const customer = allCustomers[x] if (customer.__id === deletedDoc.__id) { allCustomers.splice(x, 1) } } setCustomers(allCustomers) } }, [deletedDoc]) useEffect(() =&gt; { async function findCustomers() { const findCustomers = await Customer.find({}) if (!findCustomers) { return } if (findCustomers.data) { setCustomers(findCustomers.data) } } console.log('finding') if (customers.length === 0) { findCustomers() } }, [customers]) return ( &lt;&gt; &lt;Grid container spacing={3}&gt; &lt;Grid item xs={12}&gt; &lt;Paper className={classes.paper}&gt; &lt;Title&gt;Customers&lt;/Title&gt; &lt;ButtonGroup color='primary' aria-label='outlined primary button group'&gt; &lt;Button onClick={handleAddCustomer}&gt;Add&lt;/Button&gt; &lt;/ButtonGroup&gt; &lt;Table size='small'&gt; &lt;TableHead&gt; &lt;TableRow&gt; &lt;TableCell&gt;Name&lt;/TableCell&gt; &lt;TableCell&gt;E-mail&lt;/TableCell&gt; &lt;TableCell&gt;Address&lt;/TableCell&gt; &lt;TableCell&gt;Cards&lt;/TableCell&gt; &lt;TableCell align='right'&gt;actions&lt;/TableCell&gt; &lt;/TableRow&gt; &lt;/TableHead&gt; &lt;TableBody&gt; {customers.map((customer) =&gt; ( &lt;TableRow key={customer.id}&gt; &lt;TableCell&gt;{customer.name}&lt;/TableCell&gt; &lt;TableCell&gt;{customer.email}&lt;/TableCell&gt; &lt;TableCell&gt;{customer.address}&lt;/TableCell&gt; &lt;TableCell align='right'&gt;{customer.cards.join(' / ')}&lt;/TableCell&gt; &lt;TableCell align='right'&gt; &lt;Link color='primary' to={`/CustomersEdit/${customer.__id}`}&gt;[edit]&lt;/Link&gt; | &lt;a color='primary' href='#' onClick={e =&gt; handleDeleteCustomer(e, customer.__id)}&gt;[delete]&lt;/a&gt; &lt;/TableCell&gt; &lt;/TableRow&gt; ))} &lt;/TableBody&gt; &lt;/Table&gt; &lt;div className={classes.seeMore}&gt; Paging goes here &lt;/div&gt; &lt;/Paper&gt; &lt;/Grid&gt; &lt;/Grid&gt; &lt;/&gt; ) } The hooks: onAddDocHook // onAddDocHook.js import React from 'react' const onAddDocHook = (Model) =&gt; { const [newDoc, newDocSet] = React.useState(null) let onAddDocEventListener = null React.useEffect(() =&gt; { if (newDoc === null) { onAddDocEventListener = Model.on('add', (eventObj) =&gt; { const { error, /* document, foundation, */ data } = eventObj if (error) { return } newDocSet(data) }) } }, [newDoc]) React.useEffect(() =&gt; { return () =&gt; { // stop to listen events on component unmount Model.stopListenTo(onAddDocEventListener) onAddDocEventListener = null } }, []) return [newDoc] } export default onAddDocHook onEditDocHook // onEditDocHook.js import React from 'react' const onEditDocHook = (Model) =&gt; { const [editedDoc, editedDocSet] = React.useState(null) let onEditDocEventListener = null React.useEffect(() =&gt; { if (editedDoc === null) { onEditDocEventListener = Model.on('edit', (eventObj) =&gt; { const { error, /* document, foundation, */ data } = eventObj if (error) { return } editedDocSet(data) }) } }, [editedDoc]) React.useEffect(() =&gt; { return () =&gt; { // stop to listen events on component unmount Model.stopListenTo(onEditDocEventListener) onEditDocEventListener = null } }, []) return [editedDoc] } export default onEditDocHook onDeleteDocHook // onDeleteDocHook.js import React from 'react' const onDeleteDocHook = (Model) =&gt; { const [deletedDoc, deletedDocSet] = React.useState(null) let onDeleteDocEventListener = null React.useEffect(() =&gt; { if (deletedDoc === null) { onDeleteDocEventListener = Model.on('delete', (eventObj) =&gt; { const { error, /* document, foundation, */ data } = eventObj if (error) { return } deletedDocSet(data) }) } }, [deletedDoc]) React.useEffect(() =&gt; { return () =&gt; { // stop to listen events on component unmount Model.stopListenTo(onDeleteDocEventListener) onDeleteDocEventListener = null } }, []) return [deletedDoc] } export default onDeleteDocHook Vue Customer listing component The same React Customer listing component above can be written on Vue.js (2.0) following this approach: &lt;template&gt; &lt;main role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 px-md-4\"&gt; &lt;div class=\"d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 bcustomer-bottom\" &gt; &lt;h1 class=\"h2\"&gt;Customers&lt;/h1&gt; &lt;div class=\"btn-toolbar mb-2 mb-md-0\"&gt; &lt;div class=\"btn-group me-2\"&gt; &lt;router-link class=\"btn btn-sm btn-outline-secondary\" to=\"/Customers/add\" tag=\"button\"&gt; Add new Customer &lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"table-responsive\"&gt; &lt;table class=\"table table-striped table-sm\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;E-mail&lt;/th&gt; &lt;th&gt;Address&lt;/th&gt; &lt;th align=\"right\"&gt;Cards&lt;/th&gt; &lt;th&gt;-&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"doc in this.documents\" :key=\"doc.__id\"&gt; &lt;td&gt;{{ doc.name }}&lt;/td&gt; &lt;td&gt;{{ doc.email }}&lt;/td&gt; &lt;td&gt;{{ doc.address }}&lt;/td&gt; &lt;td&gt;{{ doc.cards }}&lt;/td&gt; &lt;td&gt; &lt;router-link class=\"primary\" :to=\"`/Customers/edit/${doc.__id}`\"&gt;[edit]&lt;/router-link&gt; | &lt;a color='primary' @click=\"handleDeleteCustomer($event, doc.__id)\" href='#'&gt;[delete]&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/main&gt; &lt;/template&gt; &lt;script&gt; /* globals */ import swal from 'sweetalert' import moment from 'moment' const formatter = new Intl.NumberFormat('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) export default { name: 'Customers', components: {}, props: {}, data: () =&gt; ({ documents: [] }), async mounted () { const { Customer } = this.$foundation.data this.onAddDocHandlerListener = Customer.on('add', this.onAddDocHandler) this.onEditDocHandlerListener = Customer.on('edit', this.onEditDocHandler) this.onDeleteDocHandlerListener = Customer.on( 'delete', this.onDeleteDocHandler ) const findCustomers = await Customer.find({}) if (findCustomers.error) { return } if (findCustomers.data) { console.log(findCustomers.data) this.$set(this, 'documents', findCustomers.data) } }, // eslint-disable-next-line vue/no-deprecated-destroyed-lifecycle beforeDestroy () { const { Customer } = this.$foundation.data Customer.stopListenTo(this.onAddDocHandlerListener) Customer.stopListenTo(this.onEditDocHandlerListener) Customer.stopListenTo(this.onDeleteDocHandlerListener) }, methods: { moment () { return moment }, swal () { return swal }, formatter () { return formatter }, onAddDocHandler (eventObj) { const { error, document, foundation, data } = eventObj console.log({ error, document, foundation, data }) if (error) { return } this.documents.unshift(data) }, onEditDocHandler (eventObj) { const { error, document, foundation, data } = eventObj console.log({ error, document, foundation, data }) this.documents.forEach((doc, index) =&gt; { if (doc.__id === data.__id) { this.$set(this.documents, index, data) } }) }, onDeleteDocHandler (eventObj) { const { error, document, foundation, data } = eventObj console.log({ error, document, foundation, data }) this.documents.forEach((doc, index) =&gt; { if (doc.__id === data.__id) { this.documents.splice(index, 1) } }) }, async handleDeleteCustomer(e, ___id) { console.log(e, ___id) const { Customer } = this.$foundation.data e.preventDefault() // console.error(___id) swal({ title: 'Are you sure?', text: 'Once deleted, you will not be able to recover this!', icon: 'warning', buttons: true, dangerMode: true }).then(async (willDelete) =&gt; { if (willDelete) { const r = await Customer.delete(___id) // console.error(r) if (r.error) { swal('Database error', e.error.message, 'error') return } swal('Poof! The order has been deleted!', { icon: 'success' }) } else { swal('The Customer is safe!') } }) } } } &lt;/script&gt; Application demos React demos React Demo app (Functional components) Demo app Demo project Demo documentation: -&gt; TODO React Demo app (Context API &amp;&amp; Functional components) Demo app Demo project Demo documentation: -&gt; TODO React Demo app (Class based components) Demo app Demo project Demo documentation: Vue Demos Demo #1: Vue, Boostrap, Vue Router, VooduX Demo app Demo project Demo documentation: TODO Demo #2: Vue, Vuex, Boostrap, Vue Router, VooduX Demo app Demo project Demo documentation: TODO DHTMLX demos Vanilla JS demo #1 See the Pen VooduX - VanillaJS playground by Eduardo Almeida (@web2solutions) on CodePen. Reasons why I created VooduX What is VooduX VooduX is an underlying agnostic application foundation that easily plugs to your brand new or existing application, built with Vue, React, or whatever. It is a set of tools that makes your data to be persistent and your application to be offline capable since from it initial days with zero configuration and free of any back end implementation. It actualy provides: A model layer based on Mongoose which simply persists data accross multiple targets. A proxy like Data API supporting different data transports Enforced Data Modeling and Data Entities driven design Application session 100% offline capable applications Asynchronous and event driven architecture. Support to develop database driven applications with no configuration and no backend dependency. Coming soon features: Event Sourcing implementation to track and persist data changes Trully multi threaded architecture by leveraging web workers. Web applications are originally single threaded applications. Realtime Data Sync Plugin based Data Transport to give you the freedom to back your web software with any kind of back end technology Data Schema generators leveraging OpenAPI speficiations (Swagger) as declarative metadata standard CRUD interfaces generators targeting React, Vue, DHTMLX and jQwidgets and leveraging OpenAPI speficiations (Swagger) as declarative metadata standard What VooduX is not? It does not replace Redux, Mobx, Vuex any any other kind of Application Management abstraction. It does not cares about how you manage your application state. It does not cares about which project standard's framework/library you employ. Vue, React, It does not matters. It does not cares about the UI framework/library you are employing. The Material UI, Boostrap, Vuetify, Sencha, DHTMLX, Dojo. Hypotethical use case on a large online app Supose the server - back end emits a Server Event to connected clients with the following info: { action: 'completed', entity: 'Order', id: 24455, customerId: 3443, lineItems: [...[{}]], totalPaid: 5430 } Supose you are currently catching your eyes at the Dashboard page in the screen where you have: Last Order Listing, Sales Chart and Total Earns Today badge. Like this: You now need to update those components based on the received Server Event. The Recent Orders component displays the name of the customer alongside it address and total paid for that specific order. In that moment, if you don't have the Customer information inside the Application State Management layer, you need to get it in another place. That is where the Application Data Management abstraction resides. Traditionaly the main applications implementation rely on directly calling an API, or even use things like the browser localStorage API, which will fails once it data size and complexity grows. Someday in a job interview, when I mentioned about this above scenario, the techinical leader asked me: \"Don't you know graphql?\" .. In that specific time, I never had used it in production, but I had all the background to explain why that question was so stupid. But I decided stay dumb and look like an idiot. Please don't think you have graphql features on a Event Sourcing implementation. Also, the Event Sourcing pattern is something almost required in any large / distributed application. This is one thing GraphQL claims about: Even if a REST API returns only a basic partial, it is still transferring more data, while GraphQL is always aiming for the smallest possible request. In an example, if the client needs a field, they request it, and if the API adds a new field, clients don’t get it, unless it’s being added into the GraphQL query. The above assumption is totally true, except when you break the \"commercial paradigm\" and take a hacker persective of what are the resources you have available. And once you add a data layer to your client side, your GraphQL becomes a white elephant. If you implement different data transports rather than only supporting classical HTTP requests, then you can eliminate the need for requests that have long response body. Yes, some evangelists don't like paradigm breaks. Not breaking, but enforcing some relativelly recent paradigms There is no wheels being reinvented. We are just leveraging well stabilished paradigms and methodologies like Entity Relationship, Data Entities, Actors, Objects, RAD, Component Engineering, Messaging Patterns, 2-way data flow over an Event Driven Architecture, Data Caching so on and so forth, to delivery agile produced MVPs that scales since from it initial days. Going against the most traditional development model, we intoduce a proxy like abstraction relying on IndexedDB as local (front end) database, which is a NoSQL database shipped with every modern browser. There are some frameworks, like Backbone, and some plugins for React and Vue that aims to use IndexedDb as database, but they are dumb and lazy in terms of data design driven development and validation. Aditionaly, VooduX abstract some kind of data transporters which is used to produce Client Events and to consume Server Events. Every event has an associated snapshot of the data state in that specific portion of time, which is not used only for Event Sourcing, but also to provide direct bindings for view components reactivity. Despite the fact that event sourcing and server events, if compared to traditional single pull, long pull or bidirectional HTTP requests, drastically reduces the server side demand, we have also a complete database running on front end. An Application Data Management abstraction gives you some capabilities such: Do not loose data on network disconnections. 100% offline capable applications. Drastically reduce server resources dependency. High performant UI reactivity. Local database queries will be faster than the required latency to reach your remote server (latency does not iinclude the time spent until the server returns the reponse) Links and references Useful links Project related resources: Techinical Reference Project repository Unit tests Report Report an issue Reference Knowledge base: PWA - Progressive web applications SPA - Single Page Applications IndexedDB Mongoose Server Side Events Event Sourcing RAD - Rapid application development Case tools Metaprogramming Entity Relationship Model Component Engineering Information Systems and Software Engineering - PDF ToDo REST transport Websocket transport Serverless transport (Firebase) Session layer Event sourcing Vue demo DHTMLX demo VanilaJS demo textual search with lunr. Workbox -&gt; https://developers.google.com/web/tools/workbox/guides/get-started × Search results Close Sponsored by WEB2 Solutions "},"DataEntity.html":{"id":"DataEntity.html","title":"Class: DataEntity","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Class: DataEntity DataEntity new DataEntity(DataEntityConfig) Data Entity API When composing web applications using this library, we strongly believe the data design and plan should be the entry point of your software design. The Entity Relationship diagram shall to be one of the initial documents you should to design before starting to write your software. We assume the Entity Relationship and Data Entity models as technique and paradigm to design the application data. If you have no idea of how agile you could to design your ER diagram, please take a look at some tools like Moon Modeler Every Data Entity in the system has it own encapsulated properties and methods that cares about where entity data is writen to and read from. The DataEntity relies on the application instance (passed to it constructor) to access the available data transports. It means you can not use DataEntity prior starting a data transport layer. This class is not for direct usage in your project, unless you are a core developer or want to understand what happens behind the scenes, you should consider to take a look at the Foundation class. Parameters: Name Type Description DataEntityConfig object Data Entity configuration Properties Name Type Description foundation string Provide Accesss to Foundation scope entity string Data entity name which this dataEntity instance is handling strategy boolean Data transport strategy schema boolean Data schema for this Data Entity abstraction. Do not declare the params __id and _id inside your schemas. Author: Eduardo Perotta de Almeida Source: DataEntity.js, line 7 Example import { Schema } from '../foundation/Foundation' const schema = new Schema({ // do not declare __id // do not declare _id name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const Customer = new DataEntity({ foundation, // Foundation instance, object entity: 'Customer', // entity name, string strategy: 'offline', // data strategy, string schema // data schema, a mongoose like schema }) // listen to add Customer Data event on Data API const onAddDocEventListener = Customer.on( 'add', function(eventObj){ const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // listen to edit Customer Data event on Data API const onEditDocEventListener = Customer.on( 'edit', function (eventObj) { const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // listen to delete Customer Data event on Data API const onDeleteDocEventListener = Customer.on( 'delete', function (eventObj) { const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // Stop to listen to events to avoid memory leak or others kind of problems // like to change the state of an unmounted component. // Do something like this -&gt; before component unmount OR before window unload Customer.stopListenTo(onAddDocEventListener) Customer.stopListenTo(onEditDocEventListener) Customer.stopListenTo(onDeleteDocEventListener) Extends EventSystem Members &lt;static&gt; _pagination :property PRIVATE - default internal paging configuration The default paging configuration is: offset: 0, limit 30. It means it will returns 30 documents starting on index 0. Type: property Source: DataEntity.js, line 151 &lt;static&gt; _schema :property PRIVATE - Holds the data schema for this Data Entity Data schema is a mongoose.Schema implementation Type: property Source: DataEntity.js, line 143 &lt;static&gt; _strategy :property PRIVATE - Holds the data transport strategy for this Data Entity. Default strategy is offline. Possible values are: - offlineFirst Data will be saved on local database first. - onlineFirst Data will be saved on remote database first. - offline Data will be saved on local database only. - online Data will be saved on remote database only. Type: property Source: DataEntity.js, line 126 &lt;static&gt; entity :getter Gets the entity name which which DataEntity instance is handling out. Gets the entity name which which DataEntity instance is handling out Type: getter Source: DataEntity.js, line 168 Example // console.log(DataEntity.entity) &lt;static&gt; schema :getter Gets the data schema related to this Entity Data API. Gets the data schema related to this Entity Data API Type: getter Source: DataEntity.js, line 179 Example // console.log(DataEntity.schema) &lt;static&gt; strategy :getter Gets the data strategy currently being used. Gets the data strategy currently being used Type: getter Source: DataEntity.js, line 190 Example // console.log(DataEntity.strategy) Methods &lt;static&gt; _listenToAllOtherSessionsStateChanges() PRIVATE - Listen to data state changes on every Application session. Listen to data state change event incoming from every other Application session and communicates to every subscriber tied to this session. The application scope is the browser running the application. Every tab is considered a session. Internally it triggers all events related to data change events, except if the source, the session which originated the event, is the same that is receiving the event It does not rely on network to propagate the changes. Source: DataEntity.js, line 592 Example this.#_listenToAllOtherSessionsStateChanges() &lt;static&gt; _sendStateChangeToAllOtherSessions(state) PRIVATE - Sends data state changes information to every other current application session. The application scope is the browser running the application. Every tab is considered a session. It can not rely on network. Parameters: Name Type Description state object Object containing all information about the state Properties Name Type Description data object The modified data, default is null if not provided error object | string The returned error when trying to modify the data, default is null if not provided document object The raw object used as value to get the new data state, default is {} if not provided Source: DataEntity.js, line 629 Example this.#_sendStateChangeToAllOtherSessions({ action: 'add', data: {...newDocument}, error: null, document: {...originalDocument} }) &lt;static&gt; _triggerAddEvents(eventPayload) PRIVATE - Triggers all events related to 'add document' event. PRIVATE - Triggers all events related to 'add document' event Parameters: Name Type Description eventPayload object Object containing all information about the event Properties Name Type Description data object The new document inserted into database, default is null if not provided error object | string The returned error from database add request if any, default is null if not provided primaryKey number The primaryKey value of the added document, default is zero if not provided rawObj object The raw document object provided on dataEntity.add(doc) mehod call. Default is {} if not provided. Source: DataEntity.js, line 273 &lt;static&gt; _triggerDeleteEvents(eventPayload) PRIVATE - Triggers all events related to 'delete document' event. PRIVATE - Triggers all events related to 'delete document' event Parameters: Name Type Description eventPayload object Object containing all information about the event Properties Name Type Description data object A object containing the __id property of the deleted document, default is null if not provided error object | string The returned error from database edit request if any, default is null if not provided primaryKey number The primaryKey value of the deleted document, default is zero if not provided Source: DataEntity.js, line 438 &lt;static&gt; _triggerEditEvents(eventPayload) PRIVATE - Triggers all events related to 'edit document' event. PRIVATE - Triggers all events related to 'edit document' event Parameters: Name Type Description eventPayload object Object containing all information about the event Properties Name Type Description data object The new document updated into database, default is null if not provided error object | string The returned error from database edit request if any, default is null if not provided primaryKey number The primaryKey value of the edited document, default is zero if not provided rawObj object The raw document object provided on dataEntity.edit(primaryKey, doc) mehod call. Default is {} if not provided. Source: DataEntity.js, line 374 &lt;async, static&gt; add(doc) add a new document to the storage. add a new document to the storage Parameters: Name Type Description doc object A valid document validated against mongoose schema Source: DataEntity.js, line 213 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Created document Type object Example const doc = { name: 'Eduardo Almeida', address: 'Av. Beira Mar. Praia do Morro, Guarapari - ES. Brazil.', email: 'web2solucoes@gmail.com', cards: [] } const { data, error } = await Customer.add(doc) &lt;async, static&gt; count(query) count all documents based on the given query. count all documents based on the given query Parameters: Name Type Description query object The query object to count documents Source: DataEntity.js, line 564 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Documents counter Type number Example User.count({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) &lt;async, static&gt; delete(primaryKey) delete a document from the storage. delete a document from the storage Parameters: Name Type Description primaryKey string | number The primary key value of the desired document Source: DataEntity.js, line 411 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Deleted document Type object &lt;async, static&gt; edit(primaryKey, doc) Edit a document on the storage. Edit a document on the storage Parameters: Name Type Description primaryKey string | number The primary key value of the desired document doc object A valid document validated against mongoose schema Source: DataEntity.js, line 304 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Edited document Type object Example const doc = { __id: 1, _id: '601cb8d8623dc60000ee3c24', name: 'Eduardo Almeida', address: 'Av. Beira Mar. Praia do Morro, Guarapari - ES. Brazil.', email: 'web2solucoes@gmail.com', cards: [] } const { data, error } = await Customer.edit(doc.__id, doc) &lt;async, static&gt; find(query, pagination) find documents based on the given query and returns a paginated response This method will to return the documents based on the given query and the specified paging. If no query is specified, it will returns documents based on paging only. Parameters: Name Type Description query object | null The query object to search documents pagination object Pagination object. If not provided will assume internaly set pagination. Properties Name Type Description offset number Offset. Default 0. limit number Limit. Default 30. Source: DataEntity.js, line 527 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Array of Found documents Type array Example User.find({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) &lt;async, static&gt; findAll() Find all documents This method will to return all documents based on the given query. If no query is specified, it will returns all records from this collection Source: DataEntity.js, line 502 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Array of Found documents Type array &lt;async, static&gt; findById(primaryKey) find a document from the storage by ID. find a document from the storage by ID Parameters: Name Type Description primaryKey string | number The primary key value of the desired document Source: DataEntity.js, line 472 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Found document Type object &lt;static&gt; Model(doc, schema) create a Data Model based on given document. create a Data Model based on given document Parameters: Name Type Description doc object A valid document validated against mongoose schema schema object Mongoose based schema Source: DataEntity.js, line 201 Returns: model - Mongoose document Type object × Search results Close Sponsored by WEB2 Solutions "},"Foundation.html":{"id":"Foundation.html","title":"Class: Foundation","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Class: Foundation Foundation new Foundation(config) Foundation boostrap class. Foundation boostrap class Parameters: Name Type Description config object Foundation configuration Properties Name Type Description name string Foundation name dataStrategy string Data strategy. Recognized values: offlineFirst, onlineFirst, offline, online useWorker boolean Use a ServiceWorker in Background schemas object map of data schemas Author: Eduardo Perotta de Almeida Source: Foundation.js, line 9 Example // =========&gt; main.js // import React import React from 'react' import ReactDOM from 'react-dom' // import Bootstrap import 'bootstrap/dist/css/bootstrap.css' // import React app import App from './App' // import agnostic foundation foundation class import Foundation from './foundation/Foundation' const CustomerSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const OrderSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, shipTo: { type: String, required: true, index: true }, paymentMethod: { type: String, required: true, index: true }, amount: { type: Number, required: true, default: 0, index: true }, date: { type: Date, default: Date.now, index: true } }) const ProductSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new Foundation.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Foundation({ name: 'My App', useWorker: true, dataStrategy: 'offline', schemas: { User: UserSchema, Product: ProductSchema, Order: OrderSchema, Customer: CustomerSchema } }) foundation.on('foundation:start', async function(eventObj) { const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start foundation and get it ready to be used await foundation.start() const start = await foundation.start() if (start.error) { throw new Error(`Error starting foundation stack: ${start.error}`) } // console.debug('start', start) ReactDOM.render( &lt;App foundation={foundation} /&gt;, document.getElementById('root') ) Extends EventSystem Members &lt;static&gt; applicationWorker :getter Get the Foundation worker. Get the Foundation worker Type: getter Source: Foundation.js, line 278 Example Foundation.applicationWorker.postMessage() &lt;static&gt; data :getter Get the Foundation data API(DataEntity). Get the Foundation data API(DataEntity) Type: getter Source: Foundation.js, line 219 Example const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug(Eduardo) // { // data: {__id: 1, _id: \"600e0ae8d9d7f50000e1444b\", name: \"Eduardo Almeida\", username: \"web2\", id: \"600e0ae8d9d7f50000e1444b\"} // error: null // } &lt;static&gt; dataStrategy :getter Get the data strategy being used. Get the data strategy being used. Possible values are: offlineFirst, onlineFirst, offline, online. Default: offlineFirst Type: getter Source: Foundation.js, line 200 Example console.log(Foundation.dataStrategy) &lt;static&gt; guid :getter Get the Foundation Session guid currently being used. Get the Foundation Session guid currently being used. Type: getter Source: Foundation.js, line 210 Example console.log(Foundation.guid) &lt;static&gt; name :getter Get the Foundation name. Get the Foundation name Type: getter Source: Foundation.js, line 248 Example console.log(Foundation.name) &lt;static&gt; name :setter Set the Foundation name. Set the Foundation name Type: setter Source: Foundation.js, line 258 Example Foundation.name = 'Provide the name here' &lt;static&gt; Schema :getter Creates new data schema. Creates new data schema Type: getter Source: Foundation.js, line 307 Example new Foundation.Schema({}) &lt;static&gt; started :getter Get the start state. Get the start state Type: getter Source: Foundation.js, line 269 Example console.log(Foundation.started) &lt;static&gt; tabId :getter Get the Browser tab ID. Get the Browser tab ID Type: getter Source: Foundation.js, line 238 Example console.log(foundation.tabId) &lt;static&gt; useWorker :getter flag if is there ServiceWorker being used. flag if is there ServiceWorker being used Type: getter Source: Foundation.js, line 428 Methods &lt;async, static&gt; registerApplicationWorker() Setup and Register the main Service worker used by foundation core. Setup and Register the main Service worker used by foundation core Source: Foundation.js, line 463 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Worker Registration Object Type object &lt;async, static&gt; registerWorker(name, workerFile) Setup and Register a Service worker and get it ready for usage into your application scope. Setup and Register a Service worker and get it ready for usage into your application scope Parameters: Name Type Description name string Worker name. Used to access it from the namespace workerFile string Worker file name Source: Foundation.js, line 499 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Worker Registration Object Type object &lt;static&gt; importDataEntity(spec) Alias to Foundation.mapToDataEntityAPI(entity = '', dataEntity = {}) An Data Entity abstraction is an instance of the DataEntity. Once it is mapped to foundation Data API, you can reach every Data Entity in the system from a single source point. This method dont works as expected if you call it after Foundation.start method Parameters: Name Type Description spec object Data Entity abstraction specification Properties Name Type Description entity string Data Entity name dataEntity dataEntity An DataEntity instance for the entity defined on `spec.entity` Source: Foundation.js, line 318 Example const productSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price: { type: Number, required: true, index: true } }) // start the foundation const foundation = new Foundation({ name: 'My Test app', schemas: { // Customer: schema } }) // Build a customized Data Entity abstraction const MyCustomizedDataEntity = class extends DataEntity { constructor (config) { super(config) } sell (primaryKey, orderId) { // primaryKey is Product primary key value // orderId is the primaryKey of an Order // const foundOrder = await Order.findById(orderId) // if (foundOrder.error) { // CAN NOT TO SELL // } // const items = foundOrder.data.lineItems.filter(i =&gt; (i.productId === primaryKey)) // If Order has the product listed item // if(items[0]) // { // await this.delete(primaryKey) // deletes a Product from Products // } } } // instance of the custimized Data Entity const productDataEntity = new MyCustomizedDataEntity({ foundation, entity: 'Product', schema: productSchema }) // import data entity foundation.importDataEntity({ entity: 'Product', dataEntity: productDataEntity }) // start the foundation await foundation.start() // you can now do things like: const { Product } = foundation.data await Product.add({ name: 'Big Mac', vendor: 'McDonalds', price: 3 }) &lt;static&gt; mapToDataEntityAPI(entity, dataEntity) Maps an Data Entity abstraction to foundation Data API An Data Entity abstraction is an instance of the DataEntity. Once it is mapped to foundation Data API, you can reach every Data Entity in the system from a single source point. This method dont works as expected if you call it after Foundation.start method. See Foundation.importDataEntity for usage further information. Parameters: Name Type Description entity string Data Entity name dataEntity dataEntity An DataEntity instance Source: Foundation.js, line 288 &lt;static&gt; setGuidStorage(guid) save Foundation uuid to localStorage. save Foundation uuid to localStorage Parameters: Name Type Description guid string Source: Foundation.js, line 437 Returns: Foundation uuid saved on localStorage &lt;static&gt; setupAppGuid() check if Foundation has a uuid saved o. check if Foundation has a uuid saved o Source: Foundation.js, line 448 Returns: Foundation uuid saved on localStorage &lt;async, static&gt; start() Starts foundation stack and get it ready to use. Starts foundation stack and get it ready to use. it calls this.#startVitals() internally Source: Foundation.js, line 538 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Foundation data Type object × Search results Close Sponsored by WEB2 Solutions "},"LocalDatabaseTransport.html":{"id":"LocalDatabaseTransport.html","title":"Class: LocalDatabaseTransport","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Class: LocalDatabaseTransport LocalDatabaseTransport new LocalDatabaseTransport(config) Database transport for IndexedDB. Database transport for IndexedDB Parameters: Name Type Description config object Transport configuration Properties Name Type Description version number Database version. Same as IndexedDB database version. tables object Database tables. Dexie tables configuration. dbName string Database name. Same as IndexedDB database name. Author: Eduardo Perotta de Almeida Source: LocalDatabaseTransport.js, line 9 See: The Data Transport is set into the Foundation stack and it is consumed inside DataEntity to persist data locally. LocalDatabaseTransport extends Dexie as database handler for IndexedDB. See Dexie Example import LocalDatabaseTransport from './LocalDatabaseTransport' import { Schema } from './utils' const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const ProductSchema = new Schema({ // ... }) const dbName = 'MyDatabaseName' const localDataTransport = new LocalDatabaseTransport({ version: 1, // default 1 tables: {}, // default {} dbName }) // or const localDataTransport = new LocalDatabaseTransport({ dbName }) localDataTransport.addSchema('User', UserSchema) localDataTransport.addSchema('Product', ProductSchema) await localDataTransport.connect() const Biden = await localDataTransport.table('User').add({ name: 'Joe Biden', username: 'biden'}) const Ferrari = await localDataTransport.table('Product').add({ name: 'Ferrari', vendor: 'Ferrari', price_cost: 3000000}) Extends dexie Methods &lt;static&gt; addSchema(schemaName, schema) A a Data Schema into the Schema tree. A a Data Schema into the Schema tree Parameters: Name Type Description schemaName string The schema name. Same as Entity name. schema object A valid mongoose like schema Source: LocalDatabaseTransport.js, line 91 Returns: schema - The schema enty from inside the Schema tree Type object Example const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) localDataTransport.addSchema('User', UserSchema) &lt;async, static&gt; connect() Setup connection to local database. Setup connection to local database Source: LocalDatabaseTransport.js, line 115 Returns: Foundation uuid saved on localStorage signature - Default methods signature format { error, data } Type object signature.error - Execution error information Type string | object signature.data - Connection information Type object Example await localDataTransport.connect() × Search results Close Sponsored by WEB2 Solutions "},"module-utils.html":{"id":"module-utils.html","title":"Module: utils","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Module: utils Author: Eduardo Perotta de Almeida Source: utils.js, line 6 Methods &lt;static&gt; createMethodSignature(error, data) createMethodSignature Create default signature method object. createMethodSignature Create default signature method object Parameters: Name Type Description error string | object The string or error object if have any data object | array | number | string | boolean Information about method execution Source: utils.js, line 21 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Execution data Type object | array | number | string | boolean &lt;static&gt; genDbName(appName) genDbName generates a database name. genDbName generates a database name Parameters: Name Type Description appName string Voodux Application Instance name Source: utils.js, line 47 Returns: dbName / uuid Type string &lt;static&gt; getSearchTokenStream() getSearchTokenStream generates a lunr search token. getSearchTokenStream generates a lunr search token. See lunr search Source: utils.js, line 164 Returns: token Type array &lt;static&gt; mongooseToDexieTableString() mongooseToDexieTableString convert given Mongoose schema to a Dexie Table columns configuration. mongooseToDexieTableString convert given Mongoose schema to a Dexie Table columns configuration. All columns inside returned configuration are indexed at IndexedDB prepend __id as local primary key and _id for remote primary key Local primary key is integer and auto incremented Source: utils.js, line 76 Returns: Dexie table configuration string Type string &lt;static&gt; toJSON(obj) toJSON - stringify and parse an object It uses native JSON internally. toJSON - stringify and parse an object It uses native JSON internally. Parameters: Name Type Description obj string | object Valid JSON object or string Source: utils.js, line 60 Returns: new JSON object Type object &lt;static&gt; uuid() uuid generates a Universally unique identifier string. uuid generates a Universally unique identifier string Source: utils.js, line 32 Returns: guid / uuid Type string &lt;inner&gt; getCompoundIndexes(notIndexed, schema) PRIVATE getCompoundIndexes() - get compound indexes in a schema Compound keys are NOT initially indexed on schema property level, then we need to iterate over schema._index[0], which is the arrray containing all indexes including the compounds Parameters: Name Type Description notIndexed array name of not indexes columns/properties. schema object data schema object instance Source: utils.js, line 126 Returns: compoundIndexes Type array × Search results Close Sponsored by WEB2 Solutions "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
