<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Application.js.html":{"id":"Application.js.html","title":"Source: Application.js","body":" Agnostic Web Application Foundation Modules utils Classes ApplicationDataAPILocalDatabaseTransport Source: Application.js /* global sessionStorage, navigator */ import { createMethodSignature, GUID } from './utils' import DataAPI from './DataAPI' import LocalDatabaseTransport from './LocalDatabaseTransport' import EventSystem from './EventSystem' const _workerOnMessage = function (event) { // console.error('_workerOnMessage') const { cmd /* , message */ } = event.data switch (cmd) { case 'responseClientId': this.triggerEvent('worker:responseClientId', { application: this, worker: this.applicationWorker, ...event.data }) break default: console.log(`Sorry, we are out of ${cmd}.`) } } /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class Application * @description Application boostrap class * @extends EventSystem * @param {object} config - Application configuration * @param {string} config.name - Application name * @param {string} config.dataStrategy - Data strategy. Recognized values: offlineFirst, onlineFirst, offline, online * @param {boolean} config.useWorker - Use a ServiceWorker in Background * @param {object} config.schemas - map of data schemas * @example {@lang javascript} import Application from './Application' import mongoose from 'mongoose' const ProductSchema = new mongoose.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new mongoose.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Application({ name: 'My App', useWorker: true, dataStrategy: 'offlineFirst', schemas: { User: UserSchema, Product: ProductSchema } }) foundation.on('application:start', function (eventObj){ const { application, error } = eventObj if (error) { throw new Error(`Error starting application stack: ${error}`) } const { User, Product } = application.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start foundation and get it ready to be used await foundation.start() */ export default class Application extends EventSystem { #_schemas #_name #_dataStrategy #_started #_models #_guid #_useWorker #_workers constructor ({ name = 'My Application Name', dataStrategy = 'offlineFirst', useWorker = false, schemas = {} } = {}) { super() this.#_name = name this.#_dataStrategy = dataStrategy this.#_useWorker = useWorker this.#_schemas = schemas this.#_started = false this.#_guid = GUID() this.#_models = {} this.#_useWorker = useWorker || false this.#_workers = {} this.localDatabaseTransport = new LocalDatabaseTransport() } /** * @member {getter} Application.dataStrategy * @Description Get the data strategy being used.&lt;br&gt; Possible values are: offlineFirst, onlineFirst, offline, online. &lt;br&gt; Default: offlineFirst * @example console.log(Application.dataStrategy) * @return {string} this.#_dataStrategy */ get dataStrategy () { return this.#_dataStrategy } /** * @member {getter} Application.guid * @description Get the Application Session guid currently being used. * @example console.log(Application.guid) */ get guid () { return this.#_guid } /** * @member {getter} Application.data * @description Get the Application data API(DataAPI) * @example const { User, Product } = application.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug(Eduardo) // { // data: {__id: 1, _id: \"600e0ae8d9d7f50000e1444b\", name: \"Eduardo Almeida\", username: \"web2\", id: \"600e0ae8d9d7f50000e1444b\"} // error: null // } */ get data() { return this.#_models } /** * @member {getter} Application.name * @name Application.name * @description Get the Application name * @example console.log(Application.name) */ get name () { return this.#_name } /** * @member {setter} Application.name * @name Application.name * @description Set the Application name * @example Application.name = 'Provide the name here' * @param {string} name - Application name */ set name (name) { this.#_name = name } /** * @member {getter} Application.started * @description Get the start state * @example console.log(Application.started) */ get started () { return this.#_started } /** * @memberof Application * @member {getter} Application.applicationWorker * @example Application.applicationWorker.postMessage() * @description Get the Application worker */ get applicationWorker() { return this.#_workers.application } #setModel(entity = '', dataAPI = {}) { let _error = null let _data = null try { this.#_models[entity] = dataAPI _data = this.#_models[entity] } catch (error) { console.error('EROROR', error) _error = error } return createMethodSignature(_error, _data) } #mapModels(schemas) { let _error = null let _data = null try { for (const entity in schemas) { if (Object.prototype.hasOwnProperty.call(schemas, entity)) { // console.debug('for (const entity in schemas)', entity) const strategy = 'offlineFirst' const schema = schemas[entity] const dataAPI = new DataAPI({ application: this, entity, strategy, schema }) this.#setModel(entity, dataAPI) } } _data = this.#_models } catch (error) { console.error(error) _error = error } return createMethodSignature(_error, _data) } /** * @member {getter} Application.useWorker * @Description flag if is there ServiceWorker being used * @return {boolean} */ get useWorker () { return this.#_useWorker } /** * @Method Application.setGuidStorage * @description save Application GUID to sessionStorage * @param {string} guid * @return Application GUID saved on sessionStorage */ setGuidStorage (guid) { sessionStorage.setItem('guid', guid) return sessionStorage.getItem('guid') } /** * @Method Application.getGuidStorage * @description get Application GUID saved on sessionStorage * @return Application GUID saved on sessionStorage */ getGuidStorage () { return sessionStorage.getItem('guid') || false } /** * @Method Application.setupAppGuid * @description check if Application has a GUID saved o * @return Application GUID saved on sessionStorage */ setupAppGuid () { const guidCache = this.getGuidStorage() || false if (guidCache) { this.#_guid = guidCache } else { this.setGuidStorage(this.#_guid) } return this.getGuidStorage() } /** * @async * @Method Application.#registerApplicationWorker * @description Setup and Register a Service worker and get it ready for usage * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Worker Registration Object */ #registerApplicationWorker (workerFile = 'ServiceWorker.js') { const self = this return new Promise((resolve, reject) =&gt; { if ('serviceWorker' in navigator) { navigator.serviceWorker .register('/' + workerFile, { // scope: '/' }) .then(function (reg) { // registration worked navigator.serviceWorker.addEventListener('message', _workerOnMessage.bind(self)) if (reg.installing) { self.#_workers['application'] = reg.installing self.#_workers['application'].postMessage({ cmd: 'getClientId', message: null }) } else if (reg.active) { self.#_workers['application'] = reg.active self.#_workers['application'].postMessage({ cmd: 'getClientId', message: null }) } resolve(createMethodSignature(null, reg)) }) .catch(function (error) { // registration failed resolve(createMethodSignature(error, null)) }) } }) } /** * @async * @Method Application.#registerApplicationWorker * @description Setup and Register a Service worker and get it ready for usage * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Worker Registration Object */ #registerWorker (name = '', workerFile = 'ServiceWorker.js') { const self = this return new Promise((resolve, reject) =&gt; { if ('serviceWorker' in navigator) { navigator.serviceWorker .register('/' + workerFile, { // scope: '/' }) .then(function (reg) { // registration worked navigator.serviceWorker.addEventListener('message', _workerOnMessage.bind(self)) if (reg.installing) { self.#_workers[name] = reg.installing self.#_workers[name].postMessage({ cmd: 'getClientId', message: null }) } else if (reg.active) { self.#_workers[name] = reg.active self.#_workers[name].postMessage({ cmd: 'getClientId', message: null }) } resolve(createMethodSignature(null, reg)) }) .catch(function (error) { // registration failed resolve(createMethodSignature(error, null)) }) } }) } /** * @Private * @description Starts application stack required items * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Application data */ async #startVitals () { let _error = null let _data = null try { this.setupAppGuid() const mapModels = this.#mapModels(this.#_schemas) await this.localDatabaseTransport.connect() // start database // start all here _data = { status: { mapModels } } } catch (error) { console.error(error) _error = error } this.triggerEvent('application:startVitals', { application: this, error: _error, data: _data }) return createMethodSignature(_error, _data) } /** * @async * @Method Application.start * @description Starts application stack and get it ready to use. &lt;br&gt; it calls this.#startVitals() internally * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Application data */ async start () { let _error = null let _data = null try { const vitals = await this.#startVitals() if (this.useWorker) { await this.#registerApplicationWorker() } this.#_started = true _data = { ...vitals.data, started: this.#_started } } catch (error) { console.error(error) _error = error } this.triggerEvent('application:start', { application: this, error: _error, data: _data }) return createMethodSignature(_error, _data) } } × Search results Close Sponsored by WEB2 Solutions "},"DataAPI.js.html":{"id":"DataAPI.js.html","title":"Source: DataAPI.js","body":" Agnostic Web Application Foundation Modules utils Classes ApplicationDataAPILocalDatabaseTransport Source: DataAPI.js // import Dexie from 'dexie' import mongoose from 'mongoose' import { createMethodSignature, GUID, toJSON } from './utils' /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class DataAPI * @description Models Data API * @extends Data * @extends DataTransportLocal * @param {object} config - Configuration factory * @param {string} config.application - Provide Accesss to Application scope * @param {string} config.entity - Data entity which the created object is handling * @param {boolean} config.strategy - Data transport strategy * @param {boolean} config.schema - Access to related data schema * @example const dataAPI = new DataAPI({ application , // Application instance, object entity, // entity name, string strategy, // data strategy, string schema // data schema, mongoose schema }) */ export default class DataAPI { #application #database #entity #strategy #schema constructor ({ application, entity, strategy, schema } = {}) { this.#entity = entity this.#strategy = strategy // offlineFirst, onlineFirst, offline, online this.#schema = schema this.#application = application // this.#database = this.#application.database /* console.error(this.#schema) console.error(this.#schema.obj) console.error(this.#schema.obj.name.type) console.error(this.#schema.obj.name.type()) console.error(this.#schema.obj.name.type().name) */ // console.error(this.#schema.paths) // console.error(Object.keys(this.#schema.paths)) // console.error(this.mongooseToDexieTableString()) /* this.version(1).stores({ [this.#entity]: this.mongooseToDexieTableString(), }); */ application.localDatabaseTransport.addSchema(this.#entity, this.#schema) } /* mongooseToDexieTableString () { const cols = [] for (const propertyName in this.#schema.paths) { if (Object.prototype.hasOwnProperty.call(this.#schema.paths, propertyName)) { const property = this.#schema.paths[propertyName] const { instance, _index, isRequired } = property // console.debug(propertyName, property) if (propertyName === '_id' || propertyName === '__id') { continue } cols.push(propertyName) } } return `++__id,_id,${cols.join(',')}` } */ get entity () { return this.#entity } static mongoose() { return mongoose; } get schema () { return this.#schema } get strategy () { return this.#strategy } Model(doc, schema) { const modelSystem = mongoose.Document modelSystem.prototype.isValid = () =&gt; modelSystem.prototype.validateSync return modelSystem(doc, schema) } /** * @async * @Method DataAPI.add * @description add a new document to the storage * @param {object} doc - A valid document validated against mongoose schema * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Created document */ async add(doc = {}) { let data = null let error = null try { const model = new this.Model(doc, this.#schema) const invalid = model.validateSync() if (invalid) { throw invalid } const rawObj = toJSON(model) const __id = await this.#application.localDatabaseTransport.table(this.#entity).add({...rawObj}) data = { __id, ...rawObj } } catch (e) { error = e } return createMethodSignature(error, data) } /** * @async * @Method DataAPI.edit * @description Edit a document on the storage * @param {string|number} identifier - The primary key value of the desired document * @param {object} doc - A valid document validated against mongoose schema * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Edited document */ async edit (identifier, doc) { // todo console.log(this.#entity, this.#strategy) } /** * @async * @Method DataAPI.delete * @description delete a document from the storage * @param {string|number} identifier - The primary key value of the desired document * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Deleted document */ async delete (identifier) { // todo console.log(this.#entity, this.#strategy) } /** * @async * @Method DataAPI.findById * @description find a document from the storage by ID * @param {string|number} identifier - The primary key value of the desired document * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Found document */ async findById (identifier) { // todo console.log(this.#entity, this.#strategy) } /** * @async * @Method DataAPI.findAll * @description find all documents * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {array} signature.data - Array of Found documents */ async findAll () { // todo console.log(this.#entity, this.#strategy) } /** * @async * @Method DataAPI.find * @description find all documents based on the given query * @param {object|null} query - The query object to search documents * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {array} signature.data - Array of Found documents */ async find(query = {}) { let data = null let error = null try { const documents = await this.#application .localDatabaseTransport .collection(this.#entity) .find(query) .toArray() data = documents } catch (e) { error = e } return createMethodSignature(error, data) } } × Search results Close Sponsored by WEB2 Solutions "},"LocalDatabaseTransport.js.html":{"id":"LocalDatabaseTransport.js.html","title":"Source: LocalDatabaseTransport.js","body":" Agnostic Web Application Foundation Modules utils Classes ApplicationDataAPILocalDatabaseTransport Source: LocalDatabaseTransport.js import dexie from 'dexie' import 'dexie-mongoify' import { createMethodSignature, mongooseToDexieTableString } from './utils' /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class LocalDatabaseTransport * @description Database transport for IndexedDB * @extends dexie * @see The Data Transport is set into the {@link Application} stack and it is consumed inside {@link DataAPI} to persist data locally. * @see {@link LocalDatabaseTransport} extends {@link https://dexie.org/docs/Dexie/Dexie|Dexie} as database handler for IndexedDB. See {@link https://dexie.org/docs/Dexie/Dexie|Dexie} * @param {object} config - Transport configuration * @param {number} config.version - Database version. &lt;br&gt;Same as IndexedDB database version. * @param {object} config.tables - Database tables. &lt;br&gt;Dexie tables configuration. * @param {string} config.dbName - Database name. &lt;br&gt;Same as IndexedDB database name. * @example {@lang javascript} import LocalDatabaseTransport from './LocalDatabaseTransport' import mongoose from 'mongoose' const UserSchema = new mongoose.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const ProductSchema = new mongoose.Schema({ // ... }) const dbName = 'MyDatabaseName' const localDataTransport = new LocalDatabaseTransport({ version: 1, // default 1 tables: {}, // default {} dbName }) // or const localDataTransport = new LocalDatabaseTransport({ dbName }) localDataTransport.addSchema('User', UserSchema) localDataTransport.addSchema('Product', ProductSchema) await localDataTransport.connect() const Biden = await localDataTransport.table('User').add({ name: 'Joe Biden', username: 'biden'}) const Ferrari = await localDataTransport.table('Product').add({ name: 'Ferrari', vendor: 'Ferrari', price_cost: 3000000}) */ export default class LocalDatabaseTransport extends dexie { #_version #_tables #_connected #_schemas #_dbName constructor ({ version = 1, tables = {}, dbName = 'DatabaseName' } = {}) { console.error('STARTED LocalDatabaseTransport') // run the super constructor Dexie(databaseName) to create the IndexedDB // database. super(dbName) this.#_dbName = dbName this.#_version = version this.#_tables = tables this.#_connected = false this.#_schemas = {} } // schema name, mongoose schema addSchema (schemaName, schema) { this.#_schemas[schemaName] = schema } async connect () { for (const entity in this.#_schemas) { if (Object.prototype.hasOwnProperty.call(this.#_schemas, entity)) { // console.error(entity) this.#_tables[entity] = mongooseToDexieTableString( this.#_schemas[entity] ) } } // console.log(this.#_schemas) // console.log(this.#_tables) console.error(' CONNECTED ') this.version(this.#_version).stores(this.#_tables) // we can retrieve our todos store with Dexie.table, and then use it as a // field on our Database class for convenience; we can now write code such // as \"this.todos.add(...)\" rather than \"this.table('todos').add(...)\" // this.todos = this.table('todos') for (const tableName in this.#_tables) { this[tableName] = this.table(tableName) } const open = await this.open() // console.debug('open', open) } } × Search results Close Sponsored by WEB2 Solutions "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" Agnostic Web Application Foundation Modules utils Classes ApplicationDataAPILocalDatabaseTransport Source: utils.js import lunr from 'lunr' /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @module utils * */ /** * createMethodSignature * Create default signature method object * @function * @param {string|object} error - The string or error object if have any * @param {object|array|number|string|boolean} data - Information about method execution * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object|array|number|string|boolean} signature.data - Execution data */ export const createMethodSignature = (error = null, data = null) =&gt; { return { error, data } } /** * GUID * generates a Universally unique identifier string - alias to uuid() * @function * @return {string} guid / uuid */ export const GUID = () =&gt; { return uuid() } /** * uuid * generates a Universally unique identifier string * @function * @return {string} guid / uuid */ export function uuid () { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { const r = (Math.random() * 16) | 0 const v = c === 'x' ? r : (r &amp; 0x3) | 0x8 return v.toString(16) }) } /** * toJSON - stringify and parse an object&lt;br&gt; It uses native JSON internally. * @function * @param {string|object} obj - Valid JSON object or string * @return {object} new JSON object */ export function toJSON (obj) { if (typeof obj === 'string') { return JSON.parse(obj) } return JSON.parse(JSON.stringify(obj)) } /** * mongooseToDexieTableString * convert given Mongoose schema to a Dexie Table columns configuration. &lt;br&gt; * All columns inside returned configuration are indexed at IndexedDB * prepend __id as local primary key and _id for remote primary key * @function * @return {string} Dexie table configuration string */ export function mongooseToDexieTableString (schema) { const cols = [] for (const propertyName in schema.paths) { if (Object.prototype.hasOwnProperty.call(schema.paths, propertyName)) { const property = schema.paths[propertyName] const { instance, _index, isRequired } = property // console.debug(propertyName, property) if (propertyName === '_id' || propertyName === '__id') { continue } if (!_index) { continue } cols.push(propertyName) } } return `++__id,_id,${cols.join(',')}` } /** * getSearchTokenStream * generates a lunr search token. See {@link https://lunrjs.com/guides/searching.html|lunr search} * @function * @return {array} token */ export function getSearchTokenStream (text = '') { const index = lunr() return index.pipeline.run(lunr.tokenizer(text)) } × Search results Close Sponsored by WEB2 Solutions "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Agnostic Web Application Foundation Modules utils Classes ApplicationDataAPILocalDatabaseTransport Modules Classes Application Application boostrap class. DataAPI Models Data API. LocalDatabaseTransport Database transport for IndexedDB. × Search results Close Sponsored by WEB2 Solutions "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Agnostic Web Application Foundation Modules utils Classes ApplicationDataAPILocalDatabaseTransport Classes Classes Application Application boostrap class. DataAPI Models Data API. LocalDatabaseTransport Database transport for IndexedDB. × Search results Close Sponsored by WEB2 Solutions "},"index.html":{"id":"index.html","title":"Index","body":" Agnostic Web Application Foundation Modules utils Classes ApplicationDataAPILocalDatabaseTransport × Search results Close Sponsored by WEB2 Solutions "},"Application.html":{"id":"Application.html","title":"Class: Application","body":" Agnostic Web Application Foundation Modules utils Classes ApplicationDataAPILocalDatabaseTransport Class: Application Application new Application(config) Application boostrap class. Application boostrap class Parameters: Name Type Description config object Application configuration Properties Name Type Description name string Application name dataStrategy string Data strategy. Recognized values: offlineFirst, onlineFirst, offline, online useWorker boolean Use a ServiceWorker in Background schemas object map of data schemas Author: Eduardo Perotta de Almeida Source: Application.js, line 32 Example import Application from './Application' import mongoose from 'mongoose' const ProductSchema = new mongoose.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new mongoose.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Application({ name: 'My App', useWorker: true, dataStrategy: 'offlineFirst', schemas: { User: UserSchema, Product: ProductSchema } }) foundation.on('application:start', function (eventObj){ const { application, error } = eventObj if (error) { throw new Error(`Error starting application stack: ${error}`) } const { User, Product } = application.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start foundation and get it ready to be used await foundation.start() Extends EventSystem Members &lt;static&gt; applicationWorker :getter Get the Application worker. Get the Application worker Type: getter Source: Application.js, line 207 Example Application.applicationWorker.postMessage() &lt;static&gt; data :getter Get the Application data API(DataAPI). Get the Application data API(DataAPI) Type: getter Source: Application.js, line 158 Example const { User, Product } = application.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug(Eduardo) // { // data: {__id: 1, _id: \"600e0ae8d9d7f50000e1444b\", name: \"Eduardo Almeida\", username: \"web2\", id: \"600e0ae8d9d7f50000e1444b\"} // error: null // } &lt;static&gt; dataStrategy :getter Get the data strategy being used. Get the data strategy being used. Possible values are: offlineFirst, onlineFirst, offline, online. Default: offlineFirst Type: getter Source: Application.js, line 139 Example console.log(Application.dataStrategy) &lt;static&gt; guid :getter Get the Application Session guid currently being used. Get the Application Session guid currently being used. Type: getter Source: Application.js, line 149 Example console.log(Application.guid) &lt;static&gt; name :setter Set the Application name. Set the Application name Type: setter Source: Application.js, line 187 Example Application.name = 'Provide the name here' &lt;static&gt; name :getter Get the Application name. Get the Application name Type: getter Source: Application.js, line 177 Example console.log(Application.name) &lt;static&gt; started :getter Get the start state. Get the start state Type: getter Source: Application.js, line 198 Example console.log(Application.started) &lt;static&gt; useWorker :getter flag if is there ServiceWorker being used. flag if is there ServiceWorker being used Type: getter Source: Application.js, line 256 Methods &lt;async, static&gt; registerApplicationWorker() Setup and Register a Service worker and get it ready for usage. Setup and Register a Service worker and get it ready for usage Source: Application.js, line 336 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Worker Registration Object Type object &lt;async, static&gt; registerApplicationWorker() Setup and Register a Service worker and get it ready for usage. Setup and Register a Service worker and get it ready for usage Source: Application.js, line 300 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Worker Registration Object Type object &lt;static&gt; getGuidStorage() get Application GUID saved on sessionStorage. get Application GUID saved on sessionStorage Source: Application.js, line 276 Returns: Application GUID saved on sessionStorage &lt;static&gt; setGuidStorage(guid) save Application GUID to sessionStorage. save Application GUID to sessionStorage Parameters: Name Type Description guid string Source: Application.js, line 265 Returns: Application GUID saved on sessionStorage &lt;static&gt; setupAppGuid() check if Application has a GUID saved o. check if Application has a GUID saved o Source: Application.js, line 285 Returns: Application GUID saved on sessionStorage &lt;async, static&gt; start() Starts application stack and get it ready to use. Starts application stack and get it ready to use. it calls this.#startVitals() internally Source: Application.js, line 407 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Application data Type object × Search results Close Sponsored by WEB2 Solutions "},"DataAPI.html":{"id":"DataAPI.html","title":"Class: DataAPI","body":" Agnostic Web Application Foundation Modules utils Classes ApplicationDataAPILocalDatabaseTransport Class: DataAPI DataAPI new DataAPI(config) Models Data API. Models Data API Parameters: Name Type Description config object Configuration factory Properties Name Type Description application string Provide Accesss to Application scope entity string Data entity which the created object is handling strategy boolean Data transport strategy schema boolean Access to related data schema Author: Eduardo Perotta de Almeida Source: DataAPI.js, line 5 Example const dataAPI = new DataAPI({ application , // Application instance, object entity, // entity name, string strategy, // data strategy, string schema // data schema, mongoose schema }) Extends Data DataTransportLocal Methods &lt;async, static&gt; add(doc) add a new document to the storage. add a new document to the storage Parameters: Name Type Description doc object A valid document validated against mongoose schema Source: DataAPI.js, line 99 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Created document Type object &lt;async, static&gt; delete(identifier) delete a document from the storage. delete a document from the storage Parameters: Name Type Description identifier string | number The primary key value of the desired document Source: DataAPI.js, line 142 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Deleted document Type object &lt;async, static&gt; edit(identifier, doc) Edit a document on the storage. Edit a document on the storage Parameters: Name Type Description identifier string | number The primary key value of the desired document doc object A valid document validated against mongoose schema Source: DataAPI.js, line 127 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Edited document Type object &lt;async, static&gt; find(query) find all documents based on the given query. find all documents based on the given query Parameters: Name Type Description query object | null The query object to search documents Source: DataAPI.js, line 183 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Array of Found documents Type array &lt;async, static&gt; findAll() find all documents. find all documents Source: DataAPI.js, line 170 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Array of Found documents Type array &lt;async, static&gt; findById(identifier) find a document from the storage by ID. find a document from the storage by ID Parameters: Name Type Description identifier string | number The primary key value of the desired document Source: DataAPI.js, line 156 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Found document Type object × Search results Close Sponsored by WEB2 Solutions "},"LocalDatabaseTransport.html":{"id":"LocalDatabaseTransport.html","title":"Class: LocalDatabaseTransport","body":" Agnostic Web Application Foundation Modules utils Classes ApplicationDataAPILocalDatabaseTransport Class: LocalDatabaseTransport LocalDatabaseTransport new LocalDatabaseTransport(config) Database transport for IndexedDB. Database transport for IndexedDB Parameters: Name Type Description config object Transport configuration Properties Name Type Description version number Database version. Same as IndexedDB database version. tables object Database tables. Dexie tables configuration. dbName string Database name. Same as IndexedDB database name. Author: Eduardo Perotta de Almeida Source: LocalDatabaseTransport.js, line 6 See: The Data Transport is set into the Application stack and it is consumed inside DataAPI to persist data locally. LocalDatabaseTransport extends Dexie as database handler for IndexedDB. See Dexie Example import LocalDatabaseTransport from './LocalDatabaseTransport' import mongoose from 'mongoose' const UserSchema = new mongoose.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const ProductSchema = new mongoose.Schema({ // ... }) const dbName = 'MyDatabaseName' const localDataTransport = new LocalDatabaseTransport({ version: 1, // default 1 tables: {}, // default {} dbName }) // or const localDataTransport = new LocalDatabaseTransport({ dbName }) localDataTransport.addSchema('User', UserSchema) localDataTransport.addSchema('Product', ProductSchema) await localDataTransport.connect() const Biden = await localDataTransport.table('User').add({ name: 'Joe Biden', username: 'biden'}) const Ferrari = await localDataTransport.table('Product').add({ name: 'Ferrari', vendor: 'Ferrari', price_cost: 3000000}) Extends dexie × Search results Close Sponsored by WEB2 Solutions "},"module-utils.html":{"id":"module-utils.html","title":"Module: utils","body":" Agnostic Web Application Foundation Modules utils Classes ApplicationDataAPILocalDatabaseTransport Module: utils Author: Eduardo Perotta de Almeida Source: utils.js, line 2 Methods &lt;static&gt; createMethodSignature(error, data) createMethodSignature Create default signature method object. createMethodSignature Create default signature method object Parameters: Name Type Description error string | object The string or error object if have any data object | array | number | string | boolean Information about method execution Source: utils.js, line 17 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Execution data Type object | array | number | string | boolean &lt;static&gt; getSearchTokenStream() getSearchTokenStream generates a lunr search token. getSearchTokenStream generates a lunr search token. See lunr search Source: utils.js, line 95 Returns: token Type array &lt;static&gt; GUID() GUID generates a Universally unique identifier string - alias to uuid(). GUID generates a Universally unique identifier string - alias to uuid() Source: utils.js, line 27 Returns: guid / uuid Type string &lt;static&gt; mongooseToDexieTableString() mongooseToDexieTableString convert given Mongoose schema to a Dexie Table columns configuration. mongooseToDexieTableString convert given Mongoose schema to a Dexie Table columns configuration. All columns inside returned configuration are indexed at IndexedDB prepend __id as local primary key and _id for remote primary key Source: utils.js, line 66 Returns: Dexie table configuration string Type string &lt;static&gt; toJSON(obj) toJSON - stringify and parse an object It uses native JSON internally. toJSON - stringify and parse an object It uses native JSON internally. Parameters: Name Type Description obj string | object Valid JSON object or string Source: utils.js, line 51 Returns: new JSON object Type object &lt;static&gt; uuid() uuid generates a Universally unique identifier string. uuid generates a Universally unique identifier string Source: utils.js, line 37 Returns: guid / uuid Type string × Search results Close Sponsored by WEB2 Solutions "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
