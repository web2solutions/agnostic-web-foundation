<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"DataEntity.js.html":{"id":"DataEntity.js.html","title":"Source: DataEntity.js","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Source: DataEntity.js /* global localStorage, navigator, window */ import EventSystem from './EventSystem' // import Dexie from 'dexie' import mongoose from 'mongoose' import { createMethodSignature, GUID, toJSON } from './utils' /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class DataEntity * @summary Data Entity API * @description When composing web applications using this library, we strongly believe the data design and plan should be the entry point of your software design. * &lt;br&gt;&lt;br&gt;The Entity Relationship diagram shall to be one of the initial documents you should to design before starting to write your software. * &lt;br&gt;&lt;br&gt;We assume the {@link https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model|Entity Relationship} and {@link https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model|Data Entity} models as technique and paradigm to design the application data. * &lt;br&gt;&lt;br&gt;If you have no idea of how agile you could to design your ER diagram, please take a look at some tools like {@Link https://www.datensen.com/data-modeling/moon-modeler-for-databases.html|Moon Modeler} * &lt;br&gt;&lt;br&gt; Every Data Entity in the system has it own encapsulated properties and methods that cares about where entity data is writen to and read from. * &lt;br&gt;&lt;br&gt; The DataEntity relies on the application instance (passed to it constructor) to access the available data transports. * &lt;br&gt;It means you can not use DataEntity prior starting a data transport layer. * &lt;br&gt;&lt;br&gt; This class is not for direct usage in your project, unless you are a core developer or want to understand what happens behind the scenes, you should consider to take a look at the {@link Foundation} class. * @extends EventSystem * @param {object} DataEntityConfig - Data Entity configuration * @param {string} DataEntityConfig.foundation - Provide Accesss to Foundation scope * @param {string} DataEntityConfig.entity - Data entity name which this dataEntity instance is handling * @param {boolean} DataEntityConfig.strategy - Data transport strategy * @param {boolean} DataEntityConfig.schema - Data schema for this Data Entity abstraction. &lt;br&gt; Do not declare the params __id and _id inside your schemas. * @example import { Schema } from '../foundation/Foundation' const schema = new Schema({ // do not declare __id // do not declare _id name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const Customer = new DataEntity({ foundation, // Foundation instance, object entity: 'Customer', // entity name, string strategy: 'offline', // data strategy, string schema // data schema, a mongoose like schema }) // listen to add Customer Data event on Data API const onAddDocEventListener = Customer.on( 'add', function(eventObj){ const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // listen to edit Customer Data event on Data API const onEditDocEventListener = Customer.on( 'edit', function (eventObj) { const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // listen to delete Customer Data event on Data API const onDeleteDocEventListener = Customer.on( 'delete', function (eventObj) { const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // Stop to listen to events to avoid memory leak or others kind of problems // like to change the state of an unmounted component. // Do something like this -&gt; before component unmount OR before window unload Customer.stopListenTo(onAddDocEventListener) Customer.stopListenTo(onEditDocEventListener) Customer.stopListenTo(onDeleteDocEventListener) */ export default class DataEntity extends EventSystem { #_foundation #_entity #_strategy #_schema #_pagination #_stateChangeStorageName constructor ({ foundation, entity, strategy, schema } = {}) { super() this.#_entity = entity this.#_strategy = strategy // offlineFirst, onlineFirst, offline, online this.#_schema = schema this.#_foundation = foundation this.#_pagination = { offset: 0, limit: 30 } this.#_stateChangeStorageName = `__$tabEntityStateChange_${this.#_entity}` this.#_foundation.localDatabaseTransport.addSchema(this.#_entity, this.#_schema) this.#_listenToAllOtherSessionsStateChanges() } /** * @memberof DataEntity.entity * @member {getter} DataEntity.entity * @example console.log(DataEntity.entity) * @description Gets the entity name which which DataEntity instance is handling out * @return {object} this.#_entity */ get entity () { return this.#_entity } /** * @memberof DataEntity.schema * @member {getter} DataEntity.schema * @example console.log(DataEntity.schema) * @description Gets the data schema related to this Entity Data API * @return {object} this.#_schema */ get schema () { return this.#_schema } /** * @memberof DataEntity * @member {getter} DataEntity.strategy * @example console.log(DataEntity.strategy) * @description Gets the data strategy currently being used * @return {string} this.#_strategy */ get strategy () { return this.#_strategy } /** * @Method DataEntity.Model * @description create a Data Model based on given document * @param {object} doc - A valid document validated against mongoose schema * @param {object} schema - Mongoose based schema * @return {object} model - Mongoose document */ Model(doc, schema) { const modelSystem = mongoose.Document modelSystem.prototype.isValid = () =&gt; modelSystem.prototype.validateSync return modelSystem(doc, schema) } /** * @async * @Method DataEntity.add * @description add a new document to the storage * @param {object} doc - A valid document validated against mongoose schema * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Created document * @example const doc = { name: 'Eduardo Almeida', address: 'Av. Beira Mar. Praia do Morro, Guarapari - ES. Brazil.', email: 'web2solucoes@gmail.com', cards: [] } const { data, error } = await Customer.add(doc) */ async add (doc = {}) { let data = null let error = null let rawObj = {} try { const model = new this.Model(doc, this.#_schema) const invalid = model.validateSync() if (invalid) { return createMethodSignature(invalid, data) } rawObj = toJSON(model) const __id = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .add({ ...rawObj }) data = { __id, ...rawObj } } catch (e) { error = e } this.#_triggerAddEvents({ data, error, primaryKey: data.__id, rawObj }) return createMethodSignature(error, data) } /** * @Method DataEntity.#_triggerAddEvents * @description PRIVATE - Triggers all events related to 'add document' event * @param {object} eventPayload - Object containing all information about the event * @param {object} eventPayload.data - The new document inserted into database, default is null if not provided * @param {object|string} eventPayload.error - The returned error from database add request if any, default is null if not provided * @param {number} eventPayload.primaryKey - The primaryKey value of the added document, default is zero if not provided * @param {object} eventPayload.rawObj - The raw document object provided on dataEntity.add(doc) mehod call. Default is {} if not provided. */ #_triggerAddEvents({ data = null, error = null, primaryKey = 0, rawObj = {} } = {}) { const action = 'add' this.#_foundation.triggerEvent(`collection:${action}:${this.#_entity.toLowerCase()}`, { foundation: this.#_foundation, entity: this.#_entity, document: rawObj, primaryKey, data, error, }) this.triggerEvent(action, { foundation: this.#_foundation, entity: this.#_entity, document: rawObj, primaryKey, data, error, }) const state = { action, data, error, document: rawObj, primaryKey } this.#_sendStateChangeToAllOtherSessions(state) } /** * @async * @Method DataEntity.edit * @description Edit a document on the storage * @param {string|number} primaryKey - The primary key value of the desired document * @param {object} doc - A valid document validated against mongoose schema * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Edited document * @example const doc = { __id: 1, _id: '601cb8d8623dc60000ee3c24', name: 'Eduardo Almeida', address: 'Av. Beira Mar. Praia do Morro, Guarapari - ES. Brazil.', email: 'web2solucoes@gmail.com', cards: [] } const { data, error } = await Customer.edit(doc.__id, doc) */ async edit(primaryKey, doc) { primaryKey = +primaryKey let data = null let error = null let rawObj = {} try { const model = new this.Model(doc, this.#_schema) const invalid = model.validateSync() if (invalid) { return createMethodSignature(invalid, data) } rawObj = toJSON(model) rawObj.__id = primaryKey console.debug('query', {primaryKey, rawObj}) const response = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .put({ ...rawObj }) // .update({ __id: primaryKey }, { ...rawObj }) console.debug('response', response) data = { __id: primaryKey, ...rawObj } /* if (response.modifiedCount === 1) { data = { __id: primaryKey, ...rawObj } } else { data = null error = { message: 'Critical query error on update', response } } */ } catch (e) { console.log(e) error = e } this.#_triggerEditEvents({ data, error, primaryKey, rawObj }) return createMethodSignature(error, data) } /** * @Method DataEntity.#_triggerEditEvents * @description PRIVATE - Triggers all events related to 'edit document' event * @param {object} eventPayload - Object containing all information about the event * @param {object} eventPayload.data - The new document updated into database, default is null if not provided * @param {object|string} eventPayload.error - The returned error from database edit request if any, default is null if not provided * @param {number} eventPayload.primaryKey - The primaryKey value of the edited document, default is zero if not provided * @param {object} eventPayload.rawObj - The raw document object provided on dataEntity.edit(primaryKey, doc) mehod call. Default is {} if not provided. */ #_triggerEditEvents({ data = null, error = null, primaryKey = 0, rawObj = {} } = {}) { const action = 'edit' this.#_foundation.triggerEvent( `collection:${action}:${this.#_entity.toLowerCase()}`, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, document: rawObj, data, error } ) this.triggerEvent( action, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, document: rawObj, data, error } ) const state = { action, data, error, document: rawObj, primaryKey } this.#_sendStateChangeToAllOtherSessions(state) } /** * @async * @Method DataEntity.delete * @description delete a document from the storage * @param {string|number} primaryKey - The primary key value of the desired document * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Deleted document */ async delete(primaryKey) { primaryKey = +primaryKey let data = null let error = null let rawObj = {} try { const __id = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .delete(primaryKey) // console.error({ __id }) data = { __id: primaryKey } } catch (e) { error = e } this.#_triggerDeleteEvents({ data, error, primaryKey }) return createMethodSignature(error, data) } /** * @Method DataEntity.#_triggerDeleteEvents * @description PRIVATE - Triggers all events related to 'delete document' event * @param {object} eventPayload - Object containing all information about the event * @param {object} eventPayload.data - A object containing the __id property of the deleted document, default is null if not provided * @param {object|string} eventPayload.error - The returned error from database edit request if any, default is null if not provided * @param {number} eventPayload.primaryKey - The primaryKey value of the deleted document, default is zero if not provided */ #_triggerDeleteEvents({ data = null, error = null, primaryKey = 0 } = {}) { const action = 'delete' this.#_foundation.triggerEvent( `collection:${action}:${this.#_entity.toLowerCase()}`, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, data, error } ) this.triggerEvent( action, { foundation: this.#_foundation, entity: this.#_entity, primaryKey, data, error } ) const state = { action, data, error, primaryKey } this.#_sendStateChangeToAllOtherSessions(state) } /** * @async * @Method DataEntity.findById * @description find a document from the storage by ID * @param {string|number} primaryKey - The primary key value of the desired document * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Found document */ async findById (primaryKey) { let data = null let error = null try { primaryKey = parseInt(primaryKey) const doc = await this.#_foundation.localDatabaseTransport .table(this.#_entity) .get(primaryKey) // console.debug({ __id: primaryKey, doc }) if (doc) { if (doc.__id === primaryKey) { data = { __id: primaryKey, ...doc } } } } catch (e) { console.error('error', error) error = e } return createMethodSignature(error, data) } /** * @async * @Method DataEntity.findAll * @description find all documents * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {array} signature.data - Array of Found documents */ async findAll(query = {}) { let data = null let error = null try { const documents = await this.#_foundation .localDatabaseTransport .collection(this.#_entity) .find(query) .toArray() data = documents } catch (e) { error = e } return createMethodSignature(error, data) } /** * @async * @Method DataEntity.find * @description find all documents based on the given query * @param {object|null} query - The query object to search documents * @param {object} pagination - Pagination object. If not provided will assume internaly set pagination. * @param {number} pagination.offset - Offset. Default 0. * @param {number} pagination.limit - Limit. Default 30. * @example User.find({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {array} signature.data - Array of Found documents */ async find(query = {}, pagination = this.#_pagination) { let { offset, limit } = pagination let data = null let error = null try { const documents = await this.#_foundation .localDatabaseTransport .collection(this.#_entity) .find(query) .reverse() .offset(offset) .limit(limit) .toArray() data = documents } catch (e) { error = e } return createMethodSignature(error, data) } /** * @async * @Method DataEntity.count * @description count all documents based on the given query * @param {object} query - The query object to count documents * @example User.count({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {number} signature.data - Documents counter */ async count (query = {}) { let data = null let error = null try { const counter = await this.#_foundation .localDatabaseTransport .collection(this.#_entity) .count(query) data = counter } catch (e) { error = e } return createMethodSignature(error, data) } /** * @Method DataEntity.#_listenToAllOtherSessionsStateChanges * @summary PRIVATE - Listen to data state changes on every Application session. * @description Listen to data state change event incoming from every other Application session and communicates to every subscriber tied to this session. * &lt;br&gt;&lt;br&gt; The application scope is the browser running the application. * &lt;br&gt;&lt;br&gt; Every tab is considered a session. * &lt;br&gt; &lt;br&gt; Internally it triggers all events related to data change events, except if the source, the session which originated the event, is the same that is receiving the event * &lt;br&gt; &lt;br&gt; It does not rely on network to propagate the changes. * @example this.#_listenToAllOtherSessionsStateChanges() */ #_listenToAllOtherSessionsStateChanges() { window.addEventListener('storage', (event) =&gt; { if (event.key === this.#_stateChangeStorageName) { const { key, newValue, oldValue } = event if (newValue) { // console.log('DATAAPI -&gt; got new state change', { key, newValue, oldValue }) const jsonState = JSON.parse(newValue) const { error, data, entity, action, source, document } = jsonState // console.error({ error, data, entity, action, source, document }) const eventObj = { foundation: this.#_foundation, entity: entity, document: document, data, error } const eventName = `collection:${action}:${entity.toLowerCase()}` this.#_foundation.triggerEvent(eventName, eventObj) this.triggerEvent(action, eventObj) } // oldValue } }) } /** * @Method DataEntity.#_sendStateChangeToAllOtherSessions * @summary PRIVATE - Sends data state changes information to every other current application session. * @description The application scope is the browser running the application. &lt;br&gt; Every tab is considered a session.&lt;br&gt; It can not rely on network. * @param {object} state - Object containing all information about the state * @param {object} state.data - The modified data, default is null if not provided * @param {object|string} state.error - The returned error when trying to modify the data, default is null if not provided * @param {object} state.document - The raw object used as value to get the new data state, default is {} if not provided * @example this.#_sendStateChangeToAllOtherSessions({ action: 'add', data: {...newDocument}, error: null, document: {...originalDocument} }) */ #_sendStateChangeToAllOtherSessions(state = { action: '', data: null, error: null, document: {} }) { state.source = { sessionId: this.#_foundation.tabId, applicationId: this.#_foundation.guid, } state.entity = this.#_entity const stateChange = JSON.stringify(state) window.localStorage.setItem(this.#_stateChangeStorageName, stateChange) window.localStorage.removeItem(this.#_stateChangeStorageName) } } × Search results Close Sponsored by WEB2 Solutions "},"Foundation.js.html":{"id":"Foundation.js.html","title":"Source: Foundation.js","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Source: Foundation.js /* global localStorage, navigator, window */ import { createMethodSignature, GUID, Schema } from './utils' import DataEntity from './DataEntity' import LocalDatabaseTransport from './LocalDatabaseTransport' import EventSystem from './EventSystem' // import workerOnMessage from './events/workerOnMessage' /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class Foundation * @description Foundation boostrap class * @extends EventSystem * @param {object} config - Foundation configuration * @param {string} config.name - Foundation name * @param {string} config.dataStrategy - Data strategy. Recognized values: offlineFirst, onlineFirst, offline, online * @param {boolean} config.useWorker - Use a ServiceWorker in Background * @param {object} config.schemas - map of data schemas * @example {@lang javascript} // =========&gt; main.js // import React import React from 'react' import ReactDOM from 'react-dom' // import Bootstrap import 'bootstrap/dist/css/bootstrap.css' // import React app import App from './App' // import agnostic foundation foundation class import Foundation from './foundation/Foundation' const CustomerSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const OrderSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, shipTo: { type: String, required: true, index: true }, paymentMethod: { type: String, required: true, index: true }, amount: { type: Number, required: true, default: 0, index: true }, date: { type: Date, default: Date.now, index: true } }) const ProductSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new Foundation.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Foundation({ name: 'My App', useWorker: true, dataStrategy: 'offlineFirst', schemas: { User: UserSchema, Product: ProductSchema, Order: OrderSchema, Customer: CustomerSchema } }) foundation.on('foundation:start', async function(eventObj) { const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start foundation and get it ready to be used await foundation.start() const start = await foundation.start() if (start.error) { throw new Error(`Error starting foundation stack: ${start.error}`) } // console.debug('start', start) ReactDOM.render( &lt;App foundation={foundation} /&gt;, document.getElementById('root') ) */ export default class Foundation extends EventSystem { #_schemas #_name #_dataStrategy #_started #_models #_guid #_useWorker #_workers #_tabId constructor ({ name = 'My Foundation Name', dataStrategy = 'offlineFirst', useWorker = false, schemas = {} } = {}) { super() this.#_name = name this.#_dataStrategy = dataStrategy this.#_useWorker = useWorker this.#_schemas = schemas this.#_started = false this.#_guid = GUID() this.#_models = {} this.#_useWorker = useWorker || false this.#_workers = {} this.localDatabaseTransport = new LocalDatabaseTransport() this.#_tabId = GUID() // assume new Id on every refresh } /** * @member {getter} Foundation.dataStrategy * @Description Get the data strategy being used.&lt;br&gt; Possible values are: offlineFirst, onlineFirst, offline, online. &lt;br&gt; Default: offlineFirst * @example console.log(Foundation.dataStrategy) * @return {string} this.#_dataStrategy */ get dataStrategy () { return this.#_dataStrategy } /** * @member {getter} Foundation.guid * @description Get the Foundation Session guid currently being used. * @example console.log(Foundation.guid) */ get guid () { return this.#_guid } /** * @member {getter} Foundation.data * @description Get the Foundation data API(DataEntity) * @example const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug(Eduardo) // { // data: {__id: 1, _id: \"600e0ae8d9d7f50000e1444b\", name: \"Eduardo Almeida\", username: \"web2\", id: \"600e0ae8d9d7f50000e1444b\"} // error: null // } */ get data() { return this.#_models } /** * @member {getter} Foundation.tabId * @description Get the Browser tab ID * @example console.log(foundation.tabId) */ get tabId() { return this.#_tabId } /** * @member {getter} Foundation.name * @name Foundation.name * @description Get the Foundation name * @example console.log(Foundation.name) */ get name () { return this.#_name } /** * @member {setter} Foundation.name * @name Foundation.name * @description Set the Foundation name * @example Foundation.name = 'Provide the name here' * @param {string} name - Foundation name */ set name (name) { this.#_name = name } /** * @member {getter} Foundation.started * @description Get the start state * @example console.log(Foundation.started) */ get started () { return this.#_started } /** * @memberof Foundation * @member {getter} Foundation.applicationWorker * @example Foundation.applicationWorker.postMessage() * @description Get the Foundation worker */ get applicationWorker() { return this.#_workers.foundation } #setModel(entity = '', dataEntity = {}) { let _error = null let _data = null this.#_models[entity] = dataEntity _data = this.#_models[entity] return createMethodSignature(_error, _data) } /** * @memberof Foundation * @member {getter} Foundation.Schema * @example new Foundation.Schema({}) * @description Creates new data schema * @returns schema creator */ static get Schema() { return Schema } #mapModels(schemas) { let _error = null let _data = null try { for (const entity in schemas) { if (Object.prototype.hasOwnProperty.call(schemas, entity)) { // console.debug('for (const entity in schemas)', entity) const strategy = 'offlineFirst' const schema = schemas[entity] const dataEntity = new DataEntity({ foundation: this, entity, strategy, schema }) this.#setModel(entity, dataEntity) } } _data = this.#_models } catch (error) { console.error(error) _error = error } return createMethodSignature(_error, _data) } /** * @member {getter} Foundation.useWorker * @Description flag if is there ServiceWorker being used * @return {boolean} */ get useWorker () { return this.#_useWorker } /** * @Method Foundation.setGuidStorage * @description save Foundation GUID to localStorage * @param {string} guid * @return Foundation GUID saved on localStorage */ setGuidStorage (guid) { window.localStorage.setItem('guid', guid) return window.localStorage.getItem('guid') } /** * @Method Foundation.setupAppGuid * @description check if Foundation has a GUID saved o * @return Foundation GUID saved on localStorage */ setupAppGuid () { const guidCache = window.localStorage.getItem('guid') || false if (guidCache) { this.#_guid = guidCache } else { this.setGuidStorage(this.#_guid) } return window.localStorage.getItem('guid') } /** * @async * @Method Foundation.#registerApplicationWorker * @description Setup and Register the main Service worker used by foundation core * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Worker Registration Object */ /* #registerApplicationWorker (workerFile = 'ServiceWorker.js') { const self = this return new Promise((resolve, reject) =&gt; { if ('serviceWorker' in navigator) { navigator.serviceWorker .register('/' + workerFile, { // scope: '/' }) .then(function (reg) { // registration worked navigator.serviceWorker.addEventListener('message', workerOnMessage.bind(self)) if (reg.installing) { self.#_workers['foundation'] = reg.installing self.#_workers['foundation'].postMessage({ cmd: 'getClientId', message: null }) } else if (reg.active) { self.#_workers['foundation'] = reg.active self.#_workers['foundation'].postMessage({ cmd: 'getClientId', message: null }) } resolve(createMethodSignature(null, reg)) }) .catch(function (error) { // registration failed resolve(createMethodSignature(error, null)) }) } }) } */ /** * @async * @Method Foundation.#registerWorker * @description Setup and Register a Service worker and get it ready for usage into your application scope * @param {string} name - Worker name. Used to access it from the namespace * @param {string} workerFile - Worker file name * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Worker Registration Object */ /* #registerWorker (name = '', workerFile = 'ServiceWorker.js') { const self = this return new Promise((resolve, reject) =&gt; { if ('serviceWorker' in navigator) { navigator.serviceWorker .register('/' + workerFile, { // scope: '/' }) .then(function (reg) { // registration worked navigator.serviceWorker.addEventListener('message', workerOnMessage.bind(self)) if (reg.installing) { self.#_workers[name] = reg.installing self.#_workers[name].postMessage({ cmd: 'getClientId', message: null }) } else if (reg.active) { self.#_workers[name] = reg.active self.#_workers[name].postMessage({ cmd: 'getClientId', message: null }) } resolve(createMethodSignature(null, reg)) }) .catch(function (error) { // registration failed resolve(createMethodSignature(error, null)) }) } }) } */ /** * @Private * @description Starts foundation stack required items * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Foundation data */ async #startVitals () { let _error = null let _data = null try { this.setupAppGuid() const mapModels = this.#mapModels(this.#_schemas) await this.localDatabaseTransport.connect() // start database // start all here _data = { status: { mapModels } } } catch (error) { console.error(error) _error = error } this.triggerEvent('foundation:startVitals', { foundation: this, error: _error, data: _data }) return createMethodSignature(_error, _data) } /** * @async * @Method Foundation.start * @description Starts foundation stack and get it ready to use. &lt;br&gt; it calls this.#startVitals() internally * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object} signature.data - Foundation data */ async start () { let _error = null let _data = null try { const vitals = await this.#startVitals() // if (this.useWorker) { // await this.#registerApplicationWorker() // } this.#_started = true _data = { ...vitals.data, started: this.#_started } } catch (error) { console.error(error) _error = error } this.triggerEvent('foundation:start', { foundation: this, error: _error, data: _data }) // console.warn('STARTED&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;', this) return createMethodSignature(_error, _data) } } × Search results Close Sponsored by WEB2 Solutions "},"LocalDatabaseTransport.js.html":{"id":"LocalDatabaseTransport.js.html","title":"Source: LocalDatabaseTransport.js","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Source: LocalDatabaseTransport.js import dexie from 'dexie' import 'dexie-mongoify' import { createMethodSignature, mongooseToDexieTableString } from './utils' dexie.debug = false /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @Class LocalDatabaseTransport * @description Database transport for IndexedDB * @extends dexie * @see The Data Transport is set into the {@link Foundation} stack and it is consumed inside {@link DataEntity} to persist data locally. * @see {@link LocalDatabaseTransport} extends {@link https://dexie.org/docs/Dexie/Dexie|Dexie} as database handler for IndexedDB. See {@link https://dexie.org/docs/Dexie/Dexie|Dexie} * @param {object} config - Transport configuration * @param {number} config.version - Database version. &lt;br&gt;Same as IndexedDB database version. * @param {object} config.tables - Database tables. &lt;br&gt;Dexie tables configuration. * @param {string} config.dbName - Database name. &lt;br&gt;Same as IndexedDB database name. * @example {@lang javascript} import LocalDatabaseTransport from './LocalDatabaseTransport' import { Schema } from './utils' const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const ProductSchema = new Schema({ // ... }) const dbName = 'MyDatabaseName' const localDataTransport = new LocalDatabaseTransport({ version: 1, // default 1 tables: {}, // default {} dbName }) // or const localDataTransport = new LocalDatabaseTransport({ dbName }) localDataTransport.addSchema('User', UserSchema) localDataTransport.addSchema('Product', ProductSchema) await localDataTransport.connect() const Biden = await localDataTransport.table('User').add({ name: 'Joe Biden', username: 'biden'}) const Ferrari = await localDataTransport.table('Product').add({ name: 'Ferrari', vendor: 'Ferrari', price_cost: 3000000}) */ export default class LocalDatabaseTransport extends dexie { #_version #_tables #_connected #_schemas #_dbName constructor ({ version = 1, tables = {}, dbName = 'DatabaseName' } = {}) { // console.error('STARTED LocalDatabaseTransport') // run the super constructor Dexie(databaseName) to create the IndexedDB // database. super(dbName) this.#_dbName = dbName this.#_version = version this.#_tables = tables this.#_connected = false this.#_schemas = {} } #_setTables() { for (const entity in this.#_schemas) { if (Object.prototype.hasOwnProperty.call(this.#_schemas, entity)) { // console.error(entity) this.#_tables[entity] = mongooseToDexieTableString( this.#_schemas[entity] ) } } } /** * @Method LocalDatabaseTransport.addSchema * @description A a Data Schema into the Schema tree * @param {string} schemaName - The schema name. Same as Entity name. * @param {object} schema - A valid mongoose like schema * @example const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) localDataTransport.addSchema('User', UserSchema) * @return {object} schema - The schema enty from inside the Schema tree */ addSchema (schemaName, schema) { this.#_schemas[schemaName] = schema return this.#_schemas[schemaName] } /** * @async * @Method LocalDatabaseTransport.connect * @description Setup connection to local database * @return Foundation GUID saved on localStorage * @example await localDataTransport.connect() * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error information * @return {object} signature.data - Connection information */ async connect() { let error = null let data = null try { this.#_setTables() this .version(this.#_version) .stores(this.#_tables) // for (const tableName in this.#_tables) { // this[tableName] = this.table(tableName) // } const open = await this.open() data = open } catch (e) { error = e data = null } return createMethodSignature(error, data) } } × Search results Close Sponsored by WEB2 Solutions "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Source: utils.js import lunr from 'lunr' import mongoose from 'mongoose' /** * @author Eduardo Perotta de Almeida &lt;web2solucoes@gmail.com&gt; * @module utils * */ /** * createMethodSignature * Create default signature method object * @function * @param {string|object} error - The string or error object if have any * @param {object|array|number|string|boolean} data - Information about method execution * @return {object} signature - Default methods signature format { error, data } * @return {string|object} signature.error - Execution error * @return {object|array|number|string|boolean} signature.data - Execution data */ export const createMethodSignature = (error = null, data = null) =&gt; { return { error, data } } /** * GUID * generates a Universally unique identifier string - alias to uuid() * @function * @return {string} guid / uuid */ export const GUID = () =&gt; { return uuid() } /** * uuid * generates a Universally unique identifier string * @function * @return {string} guid / uuid */ export function uuid () { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { const r = (Math.random() * 16) | 0 const v = c === 'x' ? r : (r &amp; 0x3) | 0x8 return v.toString(16) }) } /** * toJSON - stringify and parse an object&lt;br&gt; It uses native JSON internally. * @function * @param {string|object} obj - Valid JSON object or string * @return {object} new JSON object */ export function toJSON (obj) { if (typeof obj === 'string') { return JSON.parse(obj) } return JSON.parse(JSON.stringify(obj)) } /** * mongooseToDexieTableString * convert given Mongoose schema to a Dexie Table columns configuration. &lt;br&gt; * All columns inside returned configuration are indexed at IndexedDB * prepend __id as local primary key and _id for remote primary key * @function * @return {string} Dexie table configuration string */ export function mongooseToDexieTableString (schema) { const cols = [] for (const propertyName in schema.paths) { if (Object.prototype.hasOwnProperty.call(schema.paths, propertyName)) { const property = schema.paths[propertyName] const { // instance, _index // , // isRequired } = property // console.debug(propertyName, property) if (propertyName === '_id' || propertyName === '__id') { continue } if (!_index) { continue } cols.push(propertyName) } } return `++__id,_id${cols.length &gt; 0 ? (',' + cols.join(',')) : ''}` } /** * getSearchTokenStream * generates a lunr search token. See {@link https://lunrjs.com/guides/searching.html|lunr search} * @function * @return {array} token */ export function getSearchTokenStream (text = '') { const index = lunr() return index.pipeline.run(lunr.tokenizer(text)) } export const Schema = mongoose.Schema × Search results Close Sponsored by WEB2 Solutions "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Modules Classes DataEntity Data Entity API Foundation Foundation boostrap class. LocalDatabaseTransport Database transport for IndexedDB. × Search results Close Sponsored by WEB2 Solutions "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Classes Classes DataEntity Data Entity API Foundation Foundation boostrap class. LocalDatabaseTransport Database transport for IndexedDB. × Search results Close Sponsored by WEB2 Solutions "},"index.html":{"id":"index.html","title":"Index","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport | | | | | voodux Summary The VooduX's proposal is to cover the common lacks and mistakes in modern web applications development. It heavly opinionate on how to define a strong underlying architecture for the most common types of web softwares which relies mostly in V-* like libraries and frameworks such as Vue and React. Please don't get us wrong. We are not reinventing any wheels. We are just leveraging well stabilished paradigms and methodologies like Entity Relationship, Data Entities, Actors, Objects, RAD, Component Engineering, Messaging Patterns, Event Driven Architecture, Data Caching VooduX provides a underlying architecture offering resources like: Generic Data Schema and Data Model driven design. Use the Mongoose implementation to define models. Same model can both run on client and server. A proxy like Data Entity API supporting different data transports Enforced Entity Relatioship and Data Entities design Application session Realtime Data Sync Plugin based Data Transport to give you the freedom to back your web software with any kind of back end technology Trully multi threaded architecture by leveraging web workers. Web applications are originally single threaded applications. 100% offline capable applications Asynchronous and event driven architecture. Data Schema generators leveraging OpenAPI speficiations (Swagger) as declarative metadata standard CRUD interfaces generators targeting React, Vue, DHTMLX and jQwidgets and leveraging OpenAPI speficiations (Swagger) as declarative metadata standard What it does not? It does not replace Redux, Mobx or Vuex. It does not cares about how you manage your application state It does not cares about which framework/library for project standards you use. Vue, React ... It does not cares about the UI framework/library you use. Material UI, Boostrap, Sencha, DHTMLX, Dojo. Install Via npm - Simple usage $ npm install voodux --save Via git - Advanced usage $ git clone https://github.com/web2solutions/voodux.git $ cd voodux $ npm install How to use Importing VooduX into your application The first step to use VooduX in your project it to import it library. ES5 import const { Foundation } = require('voodux') ES6 import import { Foundation } from 'voodux' Directly on browser &lt;script type=\"text/javascript\" src=\"voodux/dist/main.min.js\"&gt;&lt;/script&gt; Writing your application code The underlying architecture of every VooduX application borns in it Data Design. The VooduX strongly believes that the Data plan and Data design is the first step to take when building successful projects. That is why we start by defining some Data Schemas for the Data entities we have in the system. Every Data entity in the system has it own encapsulated methods to access, handle and notify data changes to every actor listening to it. Schemas must be provided in the foundation constructor or at least pior calling the foundation.start() method. Otherwise it collection will not be created inside the local database. Setup a data schema for a Data Entity Every Data Schema in a VooduX application is set using the Foundation.Schema(schema) static method. The data schemas are set following the Mongoose standard to define schemas. It means you are not repeating yourself when writing data schemas because they targets both the front end and back end. In other words, server and client data are being defined by a single contract. import { Foundation } from 'voodux' const CustomerSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) Foundation constructor The starting point of every voodux application is it Foundation. The application foundation holds things like data definition, data access, data validation, data persistence, data change notification .... Prior starting your React or Vue application code, you must create your application foundation and then to pass it as property to your React or Vue application. The application foundation is set by calling the Foundation constructor. const foundation = new Foundation({ name: 'My App', useWorker: true, dataStrategy: 'offlineFirst', schemas: { User: UserSchema, Product: ProductSchema, Order: OrderSchema, Customer: CustomerSchema } }) Listening to Application Start event Sometimes you may need to start executing heavy tasks prior start rendering your application screens. For example you could start a data sync process, starting to fill out you local database and in meantime, render a dashboard and start rendering data changes in realtime, as long as they are emitted from the Data Entity abstraction implementation. The foundation:start event listener must be set before calling foundation.start(). Otherwise it will not be triggered. foundation.on('foundation:start', async function(eventObj) { const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) Setup application data and start it import React from 'react' import { Foundation } from 'voodux' const CustomerSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const OrderSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, shipTo: { type: String, required: true, index: true }, paymentMethod: { type: String, required: true, index: true }, amount: { type: Number, required: true, default: 0, index: true }, date: { type: Date, default: Date.now, index: true } }) const ProductSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new Foundation.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Foundation({ name: 'My App', useWorker: true, dataStrategy: 'offlineFirst', schemas: { User: UserSchema, Product: ProductSchema, Order: OrderSchema, Customer: CustomerSchema } }) foundation.on('foundation:start', async function(eventObj) { const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start foundation and get it ready to be used const start = await foundation.start() if (start.error) { throw new Error(`Error starting foundation stack: ${start.error}`) } // console.debug('start', start) ReactDOM.render( &lt;App foundation={foundation} /&gt;, document.getElementById('root') ) Application demos React demos React Demo app (Functional components) Demo app Demo project Demo documentation: -&gt; TODO React Demo app (Class based components) Demo app Demo project Demo documentation: Vue Demos DHTMLX demos Vanilla JS demos Motivation What motivates this Links and references API documentation Unit tests Report PWA - Progressive web applications SPA - Single Page Applications IndexedDB Mongoose Code automation tools npm run test Executes the test suite npm run start:dev Starts the dev server at 5490 port npm run build Build the application inside dist/ folder Runs npm run lint Runs npm run test Runs npm run doc Runs npm run webpack npm run doc Generates the code documentation using JSDoc npm run lint Runs lint against the code at src/ folder npm run eslint-fix Runs eslint --fix against the code at src/ folder npm run format-code Runs prettier-eslint --write against the code at src/ folder npm run webpack Transpile the es6 code (src/) to es5 version at dist/ folder ToDo REST transport Websocket transport Serverless transport (Firebase) Session layer Event sourcing Vue demo DHTMLX demo VanilaJS demo textual search with lunr. Workbox -&gt; https://developers.google.com/web/tools/workbox/guides/get-started × Search results Close Sponsored by WEB2 Solutions "},"DataEntity.html":{"id":"DataEntity.html","title":"Class: DataEntity","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Class: DataEntity DataEntity new DataEntity(DataEntityConfig) Data Entity API When composing web applications using this library, we strongly believe the data design and plan should be the entry point of your software design. The Entity Relationship diagram shall to be one of the initial documents you should to design before starting to write your software. We assume the Entity Relationship and Data Entity models as technique and paradigm to design the application data. If you have no idea of how agile you could to design your ER diagram, please take a look at some tools like Moon Modeler Every Data Entity in the system has it own encapsulated properties and methods that cares about where entity data is writen to and read from. The DataEntity relies on the application instance (passed to it constructor) to access the available data transports. It means you can not use DataEntity prior starting a data transport layer. This class is not for direct usage in your project, unless you are a core developer or want to understand what happens behind the scenes, you should consider to take a look at the Foundation class. Parameters: Name Type Description DataEntityConfig object Data Entity configuration Properties Name Type Description foundation string Provide Accesss to Foundation scope entity string Data entity name which this dataEntity instance is handling strategy boolean Data transport strategy schema boolean Data schema for this Data Entity abstraction. Do not declare the params __id and _id inside your schemas. Author: Eduardo Perotta de Almeida Source: DataEntity.js, line 7 Example import { Schema } from '../foundation/Foundation' const schema = new Schema({ // do not declare __id // do not declare _id name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const Customer = new DataEntity({ foundation, // Foundation instance, object entity: 'Customer', // entity name, string strategy: 'offline', // data strategy, string schema // data schema, a mongoose like schema }) // listen to add Customer Data event on Data API const onAddDocEventListener = Customer.on( 'add', function(eventObj){ const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // listen to edit Customer Data event on Data API const onEditDocEventListener = Customer.on( 'edit', function (eventObj) { const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // listen to delete Customer Data event on Data API const onDeleteDocEventListener = Customer.on( 'delete', function (eventObj) { const { error, document, foundation, data } = eventObj // do something like to update the component View state Based On Information from Incoming Event component.setState({ propertyName: newValue }) // React: component.$set(component.data, 'propertyName', newValue) // Vue: } ) // Stop to listen to events to avoid memory leak or others kind of problems // like to change the state of an unmounted component. // Do something like this -&gt; before component unmount OR before window unload Customer.stopListenTo(onAddDocEventListener) Customer.stopListenTo(onEditDocEventListener) Customer.stopListenTo(onDeleteDocEventListener) Extends EventSystem Members &lt;static&gt; strategy :getter Gets the data strategy currently being used. Gets the data strategy currently being used Type: getter Source: DataEntity.js, line 148 Example console.log(DataEntity.strategy) Methods &lt;static&gt; _listenToAllOtherSessionsStateChanges() PRIVATE - Listen to data state changes on every Application session. Listen to data state change event incoming from every other Application session and communicates to every subscriber tied to this session. The application scope is the browser running the application. Every tab is considered a session. Internally it triggers all events related to data change events, except if the source, the session which originated the event, is the same that is receiving the event It does not rely on network to propagate the changes. Source: DataEntity.js, line 517 Example this.#_listenToAllOtherSessionsStateChanges() &lt;static&gt; _sendStateChangeToAllOtherSessions(state) PRIVATE - Sends data state changes information to every other current application session. The application scope is the browser running the application. Every tab is considered a session. It can not rely on network. Parameters: Name Type Description state object Object containing all information about the state Properties Name Type Description data object The modified data, default is null if not provided error object | string The returned error when trying to modify the data, default is null if not provided document object The raw object used as value to get the new data state, default is {} if not provided Source: DataEntity.js, line 555 Example this.#_sendStateChangeToAllOtherSessions({ action: 'add', data: {...newDocument}, error: null, document: {...originalDocument} }) &lt;static&gt; _triggerAddEvents(eventPayload) PRIVATE - Triggers all events related to 'add document' event. PRIVATE - Triggers all events related to 'add document' event Parameters: Name Type Description eventPayload object Object containing all information about the event Properties Name Type Description data object The new document inserted into database, default is null if not provided error object | string The returned error from database add request if any, default is null if not provided primaryKey number The primaryKey value of the added document, default is zero if not provided rawObj object The raw document object provided on dataEntity.add(doc) mehod call. Default is {} if not provided. Source: DataEntity.js, line 212 &lt;static&gt; _triggerDeleteEvents(eventPayload) PRIVATE - Triggers all events related to 'delete document' event. PRIVATE - Triggers all events related to 'delete document' event Parameters: Name Type Description eventPayload object Object containing all information about the event Properties Name Type Description data object A object containing the __id property of the deleted document, default is null if not provided error object | string The returned error from database edit request if any, default is null if not provided primaryKey number The primaryKey value of the deleted document, default is zero if not provided Source: DataEntity.js, line 364 &lt;static&gt; _triggerEditEvents(eventPayload) PRIVATE - Triggers all events related to 'edit document' event. PRIVATE - Triggers all events related to 'edit document' event Parameters: Name Type Description eventPayload object Object containing all information about the event Properties Name Type Description data object The new document updated into database, default is null if not provided error object | string The returned error from database edit request if any, default is null if not provided primaryKey number The primaryKey value of the edited document, default is zero if not provided rawObj object The raw document object provided on dataEntity.edit(primaryKey, doc) mehod call. Default is {} if not provided. Source: DataEntity.js, line 300 &lt;async, static&gt; add(doc) add a new document to the storage. add a new document to the storage Parameters: Name Type Description doc object A valid document validated against mongoose schema Source: DataEntity.js, line 171 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Created document Type object Example const doc = { name: 'Eduardo Almeida', address: 'Av. Beira Mar. Praia do Morro, Guarapari - ES. Brazil.', email: 'web2solucoes@gmail.com', cards: [] } const { data, error } = await Customer.add(doc) &lt;async, static&gt; count(query) count all documents based on the given query. count all documents based on the given query Parameters: Name Type Description query object The query object to count documents Source: DataEntity.js, line 489 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Documents counter Type number Example User.count({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) &lt;async, static&gt; delete(primaryKey) delete a document from the storage. delete a document from the storage Parameters: Name Type Description primaryKey string | number The primary key value of the desired document Source: DataEntity.js, line 337 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Deleted document Type object &lt;async, static&gt; edit(primaryKey, doc) Edit a document on the storage. Edit a document on the storage Parameters: Name Type Description primaryKey string | number The primary key value of the desired document doc object A valid document validated against mongoose schema Source: DataEntity.js, line 243 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Edited document Type object Example const doc = { __id: 1, _id: '601cb8d8623dc60000ee3c24', name: 'Eduardo Almeida', address: 'Av. Beira Mar. Praia do Morro, Guarapari - ES. Brazil.', email: 'web2solucoes@gmail.com', cards: [] } const { data, error } = await Customer.edit(doc.__id, doc) &lt;async, static&gt; find(query, pagination) find all documents based on the given query. find all documents based on the given query Parameters: Name Type Description query object | null The query object to search documents pagination object Pagination object. If not provided will assume internaly set pagination. Properties Name Type Description offset number Offset. Default 0. limit number Limit. Default 30. Source: DataEntity.js, line 453 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Array of Found documents Type array Example User.find({ $or: [{ age: { $lt: 23, $ne: 20 } }, { lastname: { $in: ['Fox'] } }] }) &lt;async, static&gt; findAll() find all documents. find all documents Source: DataEntity.js, line 429 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Array of Found documents Type array &lt;async, static&gt; findById(primaryKey) find a document from the storage by ID. find a document from the storage by ID Parameters: Name Type Description primaryKey string | number The primary key value of the desired document Source: DataEntity.js, line 398 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Found document Type object &lt;static&gt; Model(doc, schema) create a Data Model based on given document. create a Data Model based on given document Parameters: Name Type Description doc object A valid document validated against mongoose schema schema object Mongoose based schema Source: DataEntity.js, line 159 Returns: model - Mongoose document Type object × Search results Close Sponsored by WEB2 Solutions "},"Foundation.html":{"id":"Foundation.html","title":"Class: Foundation","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Class: Foundation Foundation new Foundation(config) Foundation boostrap class. Foundation boostrap class Parameters: Name Type Description config object Foundation configuration Properties Name Type Description name string Foundation name dataStrategy string Data strategy. Recognized values: offlineFirst, onlineFirst, offline, online useWorker boolean Use a ServiceWorker in Background schemas object map of data schemas Author: Eduardo Perotta de Almeida Source: Foundation.js, line 9 Example // =========&gt; main.js // import React import React from 'react' import ReactDOM from 'react-dom' // import Bootstrap import 'bootstrap/dist/css/bootstrap.css' // import React app import App from './App' // import agnostic foundation foundation class import Foundation from './foundation/Foundation' const CustomerSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, address: { type: String, required: true, index: true }, email: { type: String, required: true, index: true }, cards: { type: [], required: true } }) const OrderSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, shipTo: { type: String, required: true, index: true }, paymentMethod: { type: String, required: true, index: true }, amount: { type: Number, required: true, default: 0, index: true }, date: { type: Date, default: Date.now, index: true } }) const ProductSchema = new Foundation.Schema({ name: { type: String, required: true, index: true }, vendor: { type: String, required: true, index: true }, price_cost: { type: Number, required: true, default: 0, index: true } }) const UserSchema = new Foundation.Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const foundation = new Foundation({ name: 'My App', useWorker: true, dataStrategy: 'offlineFirst', schemas: { User: UserSchema, Product: ProductSchema, Order: OrderSchema, Customer: CustomerSchema } }) foundation.on('foundation:start', async function(eventObj) { const { foundation, error } = eventObj if (error) { throw new Error(`Error starting foundation stack: ${error}`) } const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug('Eduardo', Eduardo) const Volvo = await Product.add({ name: 'Volvo XC90', vendor: 'Volvo', price_cost: 150000 }) console.debug('Volvo', Volvo) }) // start foundation and get it ready to be used await foundation.start() const start = await foundation.start() if (start.error) { throw new Error(`Error starting foundation stack: ${start.error}`) } // console.debug('start', start) ReactDOM.render( &lt;App foundation={foundation} /&gt;, document.getElementById('root') ) Extends EventSystem Members &lt;static&gt; applicationWorker :getter Get the Foundation worker. Get the Foundation worker Type: getter Source: Foundation.js, line 276 Example Foundation.applicationWorker.postMessage() &lt;static&gt; data :getter Get the Foundation data API(DataEntity). Get the Foundation data API(DataEntity) Type: getter Source: Foundation.js, line 217 Example const { User, Product } = foundation.data const Eduardo = await User.add({ name: 'Eduardo Almeida', username: 'web2' }) console.debug(Eduardo) // { // data: {__id: 1, _id: \"600e0ae8d9d7f50000e1444b\", name: \"Eduardo Almeida\", username: \"web2\", id: \"600e0ae8d9d7f50000e1444b\"} // error: null // } &lt;static&gt; dataStrategy :getter Get the data strategy being used. Get the data strategy being used. Possible values are: offlineFirst, onlineFirst, offline, online. Default: offlineFirst Type: getter Source: Foundation.js, line 198 Example console.log(Foundation.dataStrategy) &lt;static&gt; guid :getter Get the Foundation Session guid currently being used. Get the Foundation Session guid currently being used. Type: getter Source: Foundation.js, line 208 Example console.log(Foundation.guid) &lt;static&gt; name :getter Get the Foundation name. Get the Foundation name Type: getter Source: Foundation.js, line 246 Example console.log(Foundation.name) &lt;static&gt; name :setter Set the Foundation name. Set the Foundation name Type: setter Source: Foundation.js, line 256 Example Foundation.name = 'Provide the name here' &lt;static&gt; Schema :getter Creates new data schema. Creates new data schema Type: getter Source: Foundation.js, line 295 Example new Foundation.Schema({}) &lt;static&gt; started :getter Get the start state. Get the start state Type: getter Source: Foundation.js, line 267 Example console.log(Foundation.started) &lt;static&gt; tabId :getter Get the Browser tab ID. Get the Browser tab ID Type: getter Source: Foundation.js, line 236 Example console.log(foundation.tabId) &lt;static&gt; useWorker :getter flag if is there ServiceWorker being used. flag if is there ServiceWorker being used Type: getter Source: Foundation.js, line 332 Methods &lt;async, static&gt; registerApplicationWorker() Setup and Register the main Service worker used by foundation core. Setup and Register the main Service worker used by foundation core Source: Foundation.js, line 367 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Worker Registration Object Type object &lt;async, static&gt; registerWorker(name, workerFile) Setup and Register a Service worker and get it ready for usage into your application scope. Setup and Register a Service worker and get it ready for usage into your application scope Parameters: Name Type Description name string Worker name. Used to access it from the namespace workerFile string Worker file name Source: Foundation.js, line 403 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Worker Registration Object Type object &lt;static&gt; setGuidStorage(guid) save Foundation GUID to localStorage. save Foundation GUID to localStorage Parameters: Name Type Description guid string Source: Foundation.js, line 341 Returns: Foundation GUID saved on localStorage &lt;static&gt; setupAppGuid() check if Foundation has a GUID saved o. check if Foundation has a GUID saved o Source: Foundation.js, line 352 Returns: Foundation GUID saved on localStorage &lt;async, static&gt; start() Starts foundation stack and get it ready to use. Starts foundation stack and get it ready to use. it calls this.#startVitals() internally Source: Foundation.js, line 476 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Foundation data Type object × Search results Close Sponsored by WEB2 Solutions "},"LocalDatabaseTransport.html":{"id":"LocalDatabaseTransport.html","title":"Class: LocalDatabaseTransport","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Class: LocalDatabaseTransport LocalDatabaseTransport new LocalDatabaseTransport(config) Database transport for IndexedDB. Database transport for IndexedDB Parameters: Name Type Description config object Transport configuration Properties Name Type Description version number Database version. Same as IndexedDB database version. tables object Database tables. Dexie tables configuration. dbName string Database name. Same as IndexedDB database name. Author: Eduardo Perotta de Almeida Source: LocalDatabaseTransport.js, line 8 See: The Data Transport is set into the Foundation stack and it is consumed inside DataEntity to persist data locally. LocalDatabaseTransport extends Dexie as database handler for IndexedDB. See Dexie Example import LocalDatabaseTransport from './LocalDatabaseTransport' import { Schema } from './utils' const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) const ProductSchema = new Schema({ // ... }) const dbName = 'MyDatabaseName' const localDataTransport = new LocalDatabaseTransport({ version: 1, // default 1 tables: {}, // default {} dbName }) // or const localDataTransport = new LocalDatabaseTransport({ dbName }) localDataTransport.addSchema('User', UserSchema) localDataTransport.addSchema('Product', ProductSchema) await localDataTransport.connect() const Biden = await localDataTransport.table('User').add({ name: 'Joe Biden', username: 'biden'}) const Ferrari = await localDataTransport.table('Product').add({ name: 'Ferrari', vendor: 'Ferrari', price_cost: 3000000}) Extends dexie Methods &lt;static&gt; addSchema(schemaName, schema) A a Data Schema into the Schema tree. A a Data Schema into the Schema tree Parameters: Name Type Description schemaName string The schema name. Same as Entity name. schema object A valid mongoose like schema Source: LocalDatabaseTransport.js, line 90 Returns: schema - The schema enty from inside the Schema tree Type object Example const UserSchema = new Schema({ name: { type: String, required: true }, username: { type: String, required: true } }) localDataTransport.addSchema('User', UserSchema) &lt;async, static&gt; connect() Setup connection to local database. Setup connection to local database Source: LocalDatabaseTransport.js, line 114 Returns: Foundation GUID saved on localStorage signature - Default methods signature format { error, data } Type object signature.error - Execution error information Type string | object signature.data - Connection information Type object Example await localDataTransport.connect() × Search results Close Sponsored by WEB2 Solutions "},"module-utils.html":{"id":"module-utils.html","title":"Module: utils","body":" voodux Modules utils Classes DataEntityFoundationLocalDatabaseTransport Module: utils Author: Eduardo Perotta de Almeida Source: utils.js, line 3 Methods &lt;static&gt; createMethodSignature(error, data) createMethodSignature Create default signature method object. createMethodSignature Create default signature method object Parameters: Name Type Description error string | object The string or error object if have any data object | array | number | string | boolean Information about method execution Source: utils.js, line 18 Returns: signature - Default methods signature format { error, data } Type object signature.error - Execution error Type string | object signature.data - Execution data Type object | array | number | string | boolean &lt;static&gt; getSearchTokenStream() getSearchTokenStream generates a lunr search token. getSearchTokenStream generates a lunr search token. See lunr search Source: utils.js, line 96 Returns: token Type array &lt;static&gt; GUID() GUID generates a Universally unique identifier string - alias to uuid(). GUID generates a Universally unique identifier string - alias to uuid() Source: utils.js, line 28 Returns: guid / uuid Type string &lt;static&gt; mongooseToDexieTableString() mongooseToDexieTableString convert given Mongoose schema to a Dexie Table columns configuration. mongooseToDexieTableString convert given Mongoose schema to a Dexie Table columns configuration. All columns inside returned configuration are indexed at IndexedDB prepend __id as local primary key and _id for remote primary key Source: utils.js, line 67 Returns: Dexie table configuration string Type string &lt;static&gt; toJSON(obj) toJSON - stringify and parse an object It uses native JSON internally. toJSON - stringify and parse an object It uses native JSON internally. Parameters: Name Type Description obj string | object Valid JSON object or string Source: utils.js, line 52 Returns: new JSON object Type object &lt;static&gt; uuid() uuid generates a Universally unique identifier string. uuid generates a Universally unique identifier string Source: utils.js, line 38 Returns: guid / uuid Type string × Search results Close Sponsored by WEB2 Solutions "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
